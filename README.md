# Хост сайта на https://tot-maxim.github.io/simple-mkdocs-site/

# Вопросы по операционой системе

## Содержание
- [Что такое операционная система?](#что-такое-операционная-система)
- [Операционная система - Процесс](#операционная-система---процесс)
- [Операционная система - Память](#операционная-система---память)
- [Виртуализация](#виртуализация)
- [Виртуальные машины](#виртуальные-машины)
- [Prometheus](#prometheus)

### Что такое операционная система?
<details>
<summary>Что такое операционная система?</summary><br><b>

Из книги "Операционные системы: три простых шага":

"Отвечает за упрощение запуска программ (даже позволяя вам, казалось бы, запускать множество их одновременно), позволяя программам делить память, обеспечивая взаимодействие программ с устройствами и другие интересные вещи".
</b></details>

### Операционная система - Процесс

<details>
<summary>Можете объяснить, что такое процесс?</summary><br><b>

Процесс — это выполняемая программа. Программа состоит из одной или нескольких инструкций, и программа (или процесс) выполняется операционной системой.
</b></details>

<details>
<summary>Если бы вам нужно было разработать API для процессов в операционной системе, как бы выглядел этот API?</summary><br><b>

Он должен поддерживать следующее:

* Создать - позволять создавать новые процессы
* Удалить - позволять удалять/уничтожать процессы
* Состояние - позволять проверять состояние процесса, работает ли он, остановлен, ожидает и т.д.
* Остановить - позволять остановить выполняющийся процесс
</b></details>

<details>
<summary>Как создается процесс?</summary><br><b>

* Операционная система считывает код программы и любые дополнительные релевантные данные.
* Код программы загружается в память или, более конкретно, в адресное пространство процесса.
* Выделяется память для стека программы (также известного как стек выполнения). Стек также инициализируется ОС с такими данными, как argv, argc и параметры для main().
* Выделяется память для кучи программы, которая необходима для динамически выделяемых данных, таких как структуры данных, связанные списки и хеш-таблицы.
* Выполняются задачи инициализации ввода/вывода, такие как в системах на базе Unix/Linux, где у каждого процесса есть 3 дескриптора файлов (ввод, вывод и ошибка).
* ОС запускает программу, начиная с main().
</b></details>

<details>
<summary>Правда или ложь? Загрузка программы в память происходит жадно (все сразу)</summary><br><b>

Ложь. Это было верно в прошлом, но современные операционные системы выполняют ленивую загрузку, что означает, что сначала загружаются только те необходимые части, которые требуются для выполнения процесса.
</b></details>

<details>
<summary>Каковы различные состояния процесса?</summary><br><b>

* В работе - выполняет инструкции
* Готов - готов к выполнению, но по разным причинам находится в ожидании
* Заблокирован - ожидает завершения какой-то операции, например, запроса ввода-вывода с диска.
</b></details>

<details>
<summary>Каковы некоторые причины, по которым процесс может стать заблокированным?</summary><br><b>

  - Операции ввода-вывода (например, чтение с диска)
  - Ожидание пакета из сети
</b></details>

<details>
<summary>Что такое межпроцессное взаимодействие (IPC)?</summary><br><b>

Межпроцессное взаимодействие (IPC) — это механизмы, предоставляемые операционной системой, которые позволяют процессам управлять общими данными.
</b></details>

<details>
<summary>Что такое "временное разделение"? </summary><br><b>

Даже при использовании системы с одним физическим ЦПУ возможно позволить нескольким пользователям работать с ней и запускать программы. Это возможно благодаря временноё разделению, где вычислительные ресурсы делятся таким образом, что пользователю кажется, что система имеет несколько ЦПУ, хотя на самом деле это просто одно ЦПУ, которое разделяется путем применения многопрограммирования и многозадачности.
</b></details>

<details>
<summary>Что такое "пространственное разделение"?</summary><br><b>

Отчасти противоположное временно́му разделению. В то время как в (временном) разделении ресурс используется какое-то время одним субъектом, а затем тем же ресурсом может воспользоваться другой, в пространственном разделении пространство разделяется несколькими объектами, но так, что оно не передается между ними.<br>
Оно используется одним объектом, пока этот объект не решит избавиться от него. Например, в области хранения. В хранении файл принадлежит вам, пока вы не решите его удалить.
</b></details>

<details>
<summary>Какой компонент определяет, какой процесс выполняется в данный момент времени?</summary><br><b>

Планировщик ЦП
</b></details>

### Операционная система - Память

<details>
<summary>Что такое "виртуальная память" и для чего она нужна?</summary><br><b>

Виртуальная память соединяет оперативную память вашего компьютера с временным пространством на вашем жестком диске. Когда ОЗУ заканчивается, виртуальная память помогает переместить данные из ОЗУ в областъ, называемую файлом подкачки. Перемещение данных в файл подкачки может освободить ОЗУ, чтобы ваш компьютер мог выполнить свою работу. В общем, чем больше ОЗУ у вашего компьютера, тем быстрее работают программы.
https://www.minitool.com/lib/virtual-memory.html
</b></details>

<details>
<summary>Что такое подкачка по требованию?</summary><br><b>

Подкачка по требованию - это техника управления памятью, при которой страницы загружаются в физическую память только при доступе к процессом. Она оптимизирует использование памяти, загружая страницы по требованию, уменьшая время запуска и пространственные накладные расходы. Однако это вводит некоторую задержку при первом доступе к страницам. В целом, это экономичный подход к управлению ресурсами памяти в операционных системах.
</b></details>

<details>
<summary>Что такое "копирование при записи"?</summary><br><b>
Копирование при записи (COW) - это концепция управления ресурсами, целью которой является сокращение ненужного копирования информации. Это концепция, которая реализована, например, в системном вызове POSIX fork, который создает дублирующий процесс вызывающего процесса.

Идея:
1. Если ресурсы разделяются между 2 или более субъектами (например, сегменты общей памяти между 2 процессами), ресурсы не нужно копировать для каждого субъекта, а скорее каждый субъект имеет разрешение на операцию ЧТЕНИЯ на общем ресурсе. (общие сегменты помечены как только для чтения)
(Представьте, что у каждого субъекта есть указатель на местоположение общего ресурса, который может быть разыменован для чтения его значения).
2. Если один субъект выполнит операцию ЗАПиси на общий ресурс, возникнет проблема, поскольку ресурс также будет постоянно изменен для ВСЕХ других субъектов, которые его разделяют.
(Представьте, что процесс изменяет некоторые переменные в стеке или выделяет некоторые данные динамически в куче, эти изменения к общему ресурсу также будут применены для ВСЕХ других процессов, это определенно нежелательное поведение).
3. В качестве решения только в том случае, если операция ЗАПиси собирается быть выполненной на общем ресурсе, этот ресурс сначала КОПИРУЕТСЯ, а затем вносятся изменения.
</b></details>

<details>
<summary>Что такое ядро и что оно делает?</summary><br><b>

Ядро является частью операционной системы и отвечает за такие задачи, как:

  * Выделение памяти
  * Планирование процессов
  * Управление ЦП
</b></details>

<details>
<summary>Правда или ложь? Некоторые части кода в ядре загружаются в защищенные области памяти, так что приложения не могут их перезаписать.</summary><br><b>

Правда
</b></details>

<details>
<summary>Что такое POSIX?</summary><br><b>

POSIX (Portable Operating System Interface) - это набор стандартов, который определяет интерфейс между Unix-подобной операционной системой и приложениями.
</b></details>

<details>
<summary>Объясните, что такое семафор и какова его роль в операционных системах.</summary><br><b>

Семафор - это примитив синхронизации, используемый в операционных системах и конкурентном программировании для управления доступом к общим ресурсам. Это переменная или абстрактный тип данных, который действует как счетчик или механизм сигнализации для управления доступом к ресурсам несколькими процессами или потоками.
</b></details>

<details>
<summary>Что такое кэш? Что такое буфер?</summary><br><b>

Кэш: Кэш обычно используется, когда процессы читают и записывают на диск, чтобы ускорить процесс, делая доступными похожие данные, используемые различными программами.
Буфер: Зарезервированное место в ОЗУ, которое используется для временного хранения данных.
</b></details>

### Виртуализация

<details>
<summary>Что такое виртуализация?</summary><br><b>

Виртуализация использует программное обеспечение для создания абстрактного уровня над компьютерным оборудованием, который позволяет разделять аппаратные элементы одного компьютера - процессоры, память, хранилище и др. - на несколько виртуальных компьютеров, обычно называемых виртуальными машинами (VM).
</b></details>

<details>
<summary>Что такое гипервизор?</summary><br><b>

Red Hat: "Гипервизор - это программное обеспечение, которое создает и управляет виртуальными машинами (VM). Гипервизор, иногда называемый монитором виртуальных машин (VMM), изолирует операционную систему гипервизора и ресурсы от виртуальных машин и позволяет создавать и управлять этими ВМ."

Читать подробнее [здесь](https://www.redhat.com/en/topics/virtualization/what-is-a-hypervisor)
</b></details>

<details>
<summary>Какие типы гипервизоров существуют?</summary><br><b>

Гостевые гипервизоры и гипервизоры "на железе".
</b></details>

<details>
<summary>Каковы преимущества и недостатки гипервизора "на железе" по сравнению с гостевым гипервизором?</summary><br><b>

Из-за наличия собственных драйверов и прямого доступа к аппаратным компонентам гипервизор "на железе" часто обеспечивает лучшую производительность, а также стабильность и масштабируемость.

С другой стороны, вероятнее всего, будут ограничения по загрузке (любых) драйверов, поэтому гостевой гипервизор обычно выигрывает от лучшей аппаратной совместимости.
</b></details>

<details>
<summary>Какие типы виртуализации существуют?</summary><br><b>

Виртуализация операционной системы,
Виртуализация сетевых функций,
Виртуализация рабочего стола.
</b></details>

<details>
<summary>Является ли контейнеризация типом виртуализации?</summary><br><b>

Да, это виртуализация на уровне операционной системы, где ядро разделяется и позволяет использовать несколько изолированных экземпляров пользовательского пространства.
</b></details>

<details>
<summary>Как введение виртуальных машин изменило индустрию и способ развертывания приложений?</summary><br><b>

Введение виртуальных машин позволило компаниям разворачивать несколько бизнес-приложений на одном аппаратном обеспечении, при этом каждое приложение изолируется друг от друга безопасным способом и работает на своей отдельной операционной системе.
</b></details>

### Виртуальные машины

<details>
<summary>Нужны ли нам виртуальные машины в эпоху контейнеров? Они все еще актуальны?</summary><br><b>

Да, виртуальные машины все еще актуальны даже в эпоху контейнеров. Хотя контейнеры предоставляют легковесную и портативную альтернативу виртуальным машинам, у них есть определенные ограничения. Виртуальные машины по-прежнему важны, потому что они предлагают изоляцию и безопасность, могут запускать различные операционные системы и хорошо подходят для устаревших приложений. Ограничения контейнеров, например, это совместное использование ядра хоста.
</b></details>

### Prometheus

<details>
<summary>Что такое Prometheus? Каковы некоторые из основных функций Prometheus?</summary><br><b>

Prometheus - это популярный инструмент для мониторинга и оповещения с открытым исходным кодом, изначально разработанный в SoundCloud. Он предназначен для сбора и хранения данных временных рядов и позволяет выполнять запросы и анализ этих данных с помощью мощного языка запросов, называемого PromQL. Prometheus часто используется для мониторинга облако-ориентированных приложений, микросервисов и другой современной инфраструктуры.

Некоторые из основных функций Prometheus включают в себя:

1. Модель данных: Prometheus использует гибкую модель данных, которая позволяет пользователям организовывать и маркировать свои данные временных рядов таким образом, который имеет смысл для их конкретного случая использования. Метки используются для обозначения различных измерений данных, таких как источник данных или среда, в которой она была собрана.

2. Архитектура на основе извлечения: Prometheus использует модель извлечения для сбора данных из целевых систем, что означает, что сервер Prometheus активно запрашивает свои цели за метриками через регулярные интервалы. Эта архитектура более масштабируема и надежна, чем модель на основе передачи, которая требует, чтобы каждая цель передавала данные серверу.

3. База данных временных рядов: Prometheus хранит все свои данные в базе данных временных рядов, что позволяет пользователям выполнять запросы по временным диапазонам и агрегировать и анализировать свои данные различными способами. База данных оптимизирована для записей и может обрабатывать большие объемы данных с низкой задержкой.

4. Оповещение: Prometheus включает в себя мощную систему оповещения, которая позволяет пользователям определять правила на основе их данных метрик и отправлять оповещения, когда выполняются определенные условия. Оповещения могут быть отправлены по электронной почте, чату или другим каналам и могут быть настроены для включения конкретных деталей о проблеме.

5. Визуализация: Prometheus имеет встроенный инструмент для графиков и визуализации, называемый PromDash, который позволяет пользователям создавать пользовательские панели для мониторинга своих систем и приложений. PromDash поддерживает множество типов графиков и вариантов визуализации и может быть настроен с помощью CSS и JavaScript.

В целом, Prometheus является мощным и гибким инструментом для мониторинга и анализа систем и приложений и широко используется в отрасли для облачного мониторинга и наблюдаемости.
</b></details>

<details>
<summary>В каких ситуациях может быть лучше не использовать Prometheus?</summary><br><b>

Согласно документации Prometheus: "если вам нужна 100% точность, такая как выставление счетов за каждую заявку".
</b></details>

<details>
<summary>Опишите архитектуру Prometheus и его компоненты</summary><br><b>

Архитектура Prometheus состоит из четырех основных компонентов:

1. Сервер Prometheus: Сервер Prometheus отвечает за сбор и хранение данных метрик. У него есть простой встроенный уровень хранения, который позволяет хранить данные временных рядов в базе данных, упорядоченной по времени.

2. Клиентские библиотеки: Prometheus предоставляет ряд клиентских библиотек, которые позволяют приложениям предоставлять свои данные метрик в формате, который может быть принят сервером Prometheus. Эти библиотеки доступны для различных языков программирования, включая Java, Python и Go.

3. Экспортёры: Экспортёры — это программные компоненты, которые предоставляют существующие метрики из сторонних систем и делают их доступными для сбора сервером Prometheus. Prometheus предоставляет экспортёры для ряда популярных технологий, включая MySQL, PostgreSQL и Apache.

4. Alertmanager: Компонент Alertmanager отвечает за обработку оповещений, генерируемых сервером Prometheus. Он может обрабатывать оповещения из нескольких источников и предоставляет ряд функций для дублирования, группировки и маршрутизации оповещений на соответствующие каналы.

В целом архитектура Prometheus спроектирована так, чтобы быть высокомасштабируемой и резистентной. Сервер и клиентские библиотеки могут быть развернуты в распределенной манере для поддержки мониторинга в крупных и динамичных средах.
</b></details>

<details>
<summary>Можете сравнить Prometheus с другими решениями, такими как InfluxDB, например?</summary><br><b>

По сравнению с другими решениями для мониторинга, такими как InfluxDB, Prometheus известен своей высокой производительностью и масштабируемостью. Он может обрабатывать большие объемы данных и легко интегрируется с другими инструментами в экосистеме мониторинга. InfluxDB, с другой стороны, известен своей простотой и удобством использования. У него дружелюбный интерфейс и простые API для сбора и запроса данных.

Еще одно популярное решение, Nagios, представляет собой более традиционную систему мониторинга, которая опирается на модель передачи для сбора данных. Nagios существует уже долгое время и известен своей стабильностью и надежностью. Однако по сравнению с Prometheus, Nagios недостаточно продвинут в ряде функций, таких как многомерная модель данных и мощный язык запросов.

В целом выбор решения для мониторинга зависит от конкретных потребностей и требований организации. В то время как Prometheus является отличным выбором для масштабного мониторинга и оповещения, InfluxDB может быть лучшим вариантом для небольших сред, где требуется простота и удобство. Nagios остается надежным выбором для организаций, которые отдают предпочтение стабильности и надежности перед продвинутыми функциями.
</b></details>

<details>
<summary>Что такое оповещение?</summary><br><b>
В Prometheus оповещение - это уведомление, срабатывающее, когда выполняется определенное условие или порог. Оповещения могут быть настроены на срабатывание, когда определенные метрики превышают определенный порог или когда происходят конкретные события. После срабатывания оповещения оно может быть отправлено через различные каналы, такие как электронная почта, пейджер или чат, чтобы уведомить соответствующие команды или отдельных сотрудников о необходимости принять соответствующие меры. Оповещения являются критически важным компонентом любой системы мониторинга, так как они позволяют командам проактивно обнаруживать и реагировать на проблемы до того, как они повлияют на пользователей или вызовут простой системы.
</b></details>

<details>
<summary>Что такое экземпляр? Что такое задача?</summary><br><b>

В Prometheus экземпляр относится к одной целевой системе, которая мониторится. Например, один сервер или сервис. Задача - это набор экземпляров, выполняющих одну и ту же функцию, например, набор веб-серверов, обслуживающих одно и то же приложение. Задачи позволяют вам определять и управлять группой целей вместе.

По сути, экземпляр - это отдельная цель, из которой Prometheus собирает метрики, тогда как задача - это коллекция аналогичных экземпляров, которые могут управляться как группа.
</b></details>

<details>
<summary>Какие основные типы метрик поддерживает Prometheus?</summary><br><b>
Prometheus поддерживает несколько типов метрик, включая:

1. Счётчик: Монотонно возрастающее значение, используемое для отслеживания количества событий или образцов. Примеры включают количество обработанных запросов или общее количество возникших ошибок.

2. Датчик: Значение, которое может увеличиваться или уменьшаться, например, использование ЦП или использование памяти. В отличие от счётчиков, значения определенного датчика могут быть произвольными, то есть они могут увеличиваться и уменьшаться в зависимости от изменений в системе, которая мониторится.

3. Гистограмма: Набор наблюдений или событий, которые распределены по "ведрам" в зависимости от их значений. Гистограммы помогают анализировать распределение метрики, такие как задержки запросов или размеры ответов.

4. Резюме: Резюме похоже на гистограмму, но вместо ведер предоставляет набор квантилей для наблюдаемых значений. Резюме полезны для мониторинга распределения задержек запросов или размеров ответов во времени.

Prometheus также поддерживает различные функции и операторы для агрегации и манипулирования метриками, такие как sum, max, min и rate. Эти функции делают его мощным инструментом для мониторинга и оповещения по системным метрикам.
</b></details>

<details>
<summary>Что такое экспортёр? Для чего он используется?</summary><br><b>
Экспортёр служит мостом между сторонней системой или приложением и Prometheus, позволяя Prometheus мониторить и собирать данные с этой системы или приложения.

Экспортёр действует как сервер, прослушивающий определенный сетевой порт для запросов от Prometheus на извлечение метрик. Он собирает метрики из сторонней системы или приложения и преобразует их в формат, понятный Prometheus. Затем экспортёр выставляет эти метрики для Prometheus через HTTP-endpoint, что делает их доступными для сбора и анализа.

Экспортёры обычно используются для мониторинга различных компонентов инфраструктуры, таких как базы данных, веб-серверы и системы хранения. Например, существуют экспортёры для мониторинга популярных баз данных, таких как MySQL и PostgreSQL, а также веб-серверов, таких как Apache и Nginx.

В целом, экспортёры являются критически важным компонентом экосистемы Prometheus, позволяя мониторить широкий спектр систем и приложений и обеспечивая высокую степень гибкости и расширяемости платформы.
</b></details>

<details>
<summary>Каковы лучшие практики Prometheus?</summary><br><b>
Вот три из них:

1. Внимательно маркируйте: Внимательная и последовательная маркировка метрик является ключевым моментом для эффективных запросов и оповещений. Метки должны быть ясными, лаконичными и содержать всю релевантную информацию о метрике.

2. Держите метрики простыми: Метрики, предоставляемые экспортёрами, должны быть простыми и сосредоточенными на одном аспекте системы, которую мониторят. Это помогает избежать путаницы и обеспечивает легкость понимания метрик всеми членами команды.

3. Используйте оповещения умеренно: Хотя оповещение является мощной функцией Prometheus, его следует использовать умеренно и только для наиболее критичных вопросов. Установка слишком многих оповещений может привести к утомлению от оповещений и результату в том, что важные оповещения будут игнорироваться. Рекомендуется настраивать только наиболее важные оповещения и корректировать пороги с течением времени на основе фактической частоты оповещений.
</b></details>

<details>
<summary>Как получить общее количество запросов за заданный период времени?</summary><br><b>
Чтобы получить общее количество запросов за заданный период времени с помощью Prometheus, вы можете использовать функцию *sum* в комбинации с функцией *rate*. Вот пример запроса, который даст вам общее количество запросов за последний час:

```
sum(rate(http_requests_total[1h]))
```
В этом запросе *http_requests_total* - это имя метрики, отслеживающей общее количество HTTP-запросов, а функция *rate* рассчитывает скорость запросов в секунду за последний час. Функция *sum* затем суммирует все запросы, чтобы дать вам общее количество запросов за последний час.

Вы можете изменить диапазон времени, изменив продолжительность в функции *rate*. Например, если вы хотите получить общее количество запросов за последний день, вы можете изменить функцию на *rate(http_requests_total[1d])*.
</b></details>

<details>
<summary>Что означает HA в Prometheus?</summary><br><b>

HA означает Высокая Доступность. Это означает, что система спроектирована так, чтобы быть высоконадежной и всегда доступной, даже в условиях сбоев или других проблем. На практике это обычно включает в себя настройку нескольких экземпляров Prometheus и обеспечение их синхронизации и бесшовной работы вместе. Это можно достичь с помощью различных техник, таких как балансировка нагрузки, репликация и механизмы переключения на резервный вариант. Реализуя HA в Prometheus, пользователи могут гарантировать, что их данные мониторинга всегда доступны и актуальны, даже в условиях аппаратных или программных сбоев, сетевых проблем или других проблем, которые могли бы привести к прерыванию работы или потере данных.
</b></details>

<details>
<summary>Как объединить две метрики?</summary><br><b>
В Prometheus объединение двух метрик можно достичь с помощью функции *join()*. Функция *join()* объединяет две или более временных рядов на основе их значений меток. Она принимает два обязательных аргумента: *on* и *table*. Аргумент on указывает метки, по которым происходит объединение, а аргумент *table* указывает временные ряды для объединения.

Вот пример того, как объединить две метрики с помощью функции *join()*:

```
sum_series(
  join(
    on(service, instance) request_count_total,
    on(service, instance) error_count_total,
  )
)
```
В этом примере функция *join()* объединяет временные ряды *request_count_total* и *error_count_total* на основе их значений меток *service* и *instance*. Функция *sum_series()* затем рассчитывает сумму результирующих временных рядов.
</b></details>

<details>
<summary>Как написать запрос, который возвращает значение метки?</summary><br><b>
Чтобы написать запрос, который возвращает значение метки в Prometheus, вы можете использовать функцию *label_values*. Функция *label_values* принимает два аргумента: имя метки и имя метрики.

Например, если у вас есть метрика с именем *http_requests_total* с меткой под названием *method*, и вы хотите вернуть все значения метки *method*, вы можете использовать следующий запрос:

```
label_values(http_requests_total, method)
```

Это вернет список всех значений для метки *method* в метрике *http_requests_total*. Затем вы можете использовать этот список в дальнейших запросах или для фильтрации ваших данных.
</b></details>

<details>
<summary>Как преобразовать cpu_user_seconds в использование ЦП в процентах?</summary><br><b>
Чтобы преобразовать *cpu_user_seconds* в процент использования ЦП, вам нужно разделить его на общее время и количество ЦП, а затем умножить на 100. Формула следующая:

```
100 * sum(rate(process_cpu_user_seconds_total{job="<job-name>"}[<time-period>])) by (instance) / (<time-period> * <num-cpu-cores>)
```

Здесь *<job-name>* - это имя задачи, которую вы хотите запросить, *<time-period>* - это временной диапазон, который вы хотите запросить (например, *5m*, *1h*), а *<num-cpu-cores>* - количество ядер ЦП на машине, которую вы запрашиваете.

Например, чтобы получить процент использования ЦП за последние 5 минут для задачи с именем *my-job*, работающей на машине с 4 ядрами ЦП, вы можете использовать следующий запрос:

```
100 * sum(rate(process_cpu_user_seconds_total{job="my-job"}[5m])) by (instance) / (5m * 4)
```
</b></details>
