### [Назад к оглавлению](../index.md)

# Terraform

- [Terraform](#terraform)
  - [Вопросы](#вопросы)
    - [Terraform 101](#terraform-101)
    - [Основы работы с Terraform](#основы-работы-с-terraform)
    - [Зависимости](#зависимости)
    - [Провайдеры](#провайдеры)
    - [Переменные](#переменные)
      - [Входные переменные](#входные-переменные)
      - [Выходные переменные](#выходные-переменные)
      - [Переменные Hands-On](#переменные-hands-on)
    - [Источники данных](#источники-данных)
    - [Цикл жизни](#цикл-жизни)
    - [Провизионеры](#провизионеры)
    - [Локальные переменные](#локальные-переменные)
    - [Состояние](#состояние)
        - [Backend Terraform](#backend-terraform)
        - [Рабочие пространства](#рабочие-пространства)
    - [Структуры и синтаксис terraform](#структуры-и-синтаксис-terraform)
        - [Списки](#списки)
        - [Циклы](#циклы)
    - [Карты](#карты)
        - [Условные выражения](#условные-выражения)
        - [Разное](#разное)
    - [Модули](#модули)
    - [Импорт](#импорт)
    - [Контроль версий](#контроль-версий)
    - [AWS](#aws)
    - [Валидации](#валидации)
    - [Секреты](#секреты)
    - [Производство](#производство)


## Вопросы

### Terraform 101

<details>
<summary>Что такое Terraform?</summary><br><b>

[Terraform](https://www.terraform.io/intro): "HashiCorp Terraform — это инструмент инфраструктуры как кода, который позволяет вам определять как облачные, так и локальные ресурсы с помощью читаемых человеком конфигурационных файлов, которые вы можете версионировать, повторно использовать и делиться ими. Затем вы можете использовать последовательный рабочий процесс для развертывания и управления всей вашей инфраструктурой на протяжении всего ее жизненного цикла. Terraform может управлять компонентами низкого уровня, такими как вычислительные ресурсы, хранение и сеть, а также компонентами высокого уровня, такими как записи DNS и функции SaaS."
</b>
</details>


<details>
<summary>Каковы преимущества использования Terraform или IaC в целом?</summary><br><b>

- Полная автоматизация: Ранее создание, изменение и удаление ресурсов осуществлялось вручную или с помощью набора инструментов. С Terraform или другими технологиями IaC вы управляете полным жизненным циклом в автоматическом режиме.<br>
- Модульность и переиспользование: Код, написанный для определенных целей, может использоваться и собираться различными способами. Вы можете написать код для создания ресурсов в публичном облаке, и его могут использовать другие команды в своих учетных записях на том же (или другом) облаке.<br>
- Улучшение тестирования: Концепции, такие как CI, могут легко применяться к проектам на основе IaC и фрагментам кода. Это позволяет вам тестировать и проверять операции заранее.
</b></details>

<details>
<summary>Каковы некоторые функции Terraform?</summary><br><b>

- Декларативный подход: Terraform использует декларативный подход (в отличие от процедурного), чтобы определить конечное состояние ресурсов.
- Без агентов: в отличие от других технологий (например, Puppet), где используется модель агента и сервера, с Terraform вы используете различные API (облачные, сервисные и др.) для выполнения операций.
- Сообщество: У Terraform есть сильное сообщество, которое постоянно публикует модули и исправления по мере необходимости. Это обеспечивает хорошую поддержку модулей и пользователи могут быстро получать помощь в любое время.
</b>
</details>

<details>
<summary>Какой язык использует Terraform?</summary><br><b>

DSL под названием "HCL" (Hashicorp Configuration Language). Декларативный язык для определения инфраструктуры.
</b>
</details>

<details>
<summary>Каков типичный рабочий процесс Terraform?</summary><br><b>

1. Написание определений Terraform: файлы `.tf`, написанные на HCL, которые описывают желаемое состояние инфраструктуры (и запуск команды `terraform init` в самом начале).
2. Обзор: с помощью команд, таких как `terraform plan`, вы можете получить представление о том, что Terraform будет выполнять с написанными определениями.
3. Применение определений: с помощью команды `terraform apply` Terraform применит данные определения, добавляя, изменяя или удаляя ресурсы.

Этот процесс является ручным. Чаще всего он автоматизирован, поэтому пользователь отправляет PR/MR, чтобы предложить изменения в Terraform, есть процесс тестирования этих изменений, и как только они объединены, они применяются (`terraform apply`).
</b>
</details>

<details>
<summary>Каковы некоторые случаи использования Terraform?</summary><br><b>

- Пров Provisioning и управление инфраструктурой: вам необходимо автоматизировать или кодировать свою инфраструктуру, чтобы вы могли легко ее тестировать, применять и вносить необходимые изменения.
- Мультитенантная среда: вы управляете инфраструктурой на разных облаках, но ищете последовательный способ сделать это в разных облаках.
- Последовательные окружения: вы управляете такими окружениями, как тестовое, производственное, стендовое и т. д., и ищете способ сделать их последовательными, чтобы любое изменение в одном из них применялось к другим окружениям.
</b></details>

<details>
<summary>В чем разница между Terraform и такими технологиями, как Ansible, Puppet, Chef и т. д.?</summary><br><b>

Terraform считается технологией IaC. Он используется для развертывания ресурсов и управления инфраструктурой на разных платформах.

Ansible, Puppet и Chef — это технологии управления конфигурациями. Они используются, когда есть работающий экземпляр, и вы хотите применить к нему какую-либо конфигурацию, например установить приложение, применить политику безопасности и т. д.

Чтобы было понятнее, инструменты управления конфигурациями могут использоваться для развертывания ресурсов, поэтому в конечном итоге цель создания инфраструктуры может быть достигнута как с помощью Terraform, так и с помощью чего-то подобного Ansible. Разница заключается в подходе. Ansible не сохраняет состояние ресурсов, он не знает, сколько экземпляров в вашей среде, в отличие от Terraform. В то же время, хотя Terraform может выполнять задачи управления конфигурацией, у него меньше поддержки модулей для этой конкретной цели, и он не отслеживает состояние выполнения задач, как Ansible. Различия существуют, и чаще всего рекомендуется комбинировать технологии, чтобы Terraform использовался для управления инфраструктурой, а технологии управления конфигурацией — для настройки поверх этой инфраструктуры.
</b></details>


### Основы работы с Terraform

<details>
<summary>Объясните следующий блок кода Terraform

```
resource "aws_instance" "some-instance" {
  ami           = "ami-201720221991yay"
  instance_type = "t2.micro"
}
```
</summary><br><b>

Это ресурс типа "aws_instance", используемый для развертывания экземпляра. Имя ресурса (НЕ ЭКЗЕМПЛЯРА) — "some-instance".

Экземпляр будет развернут с типом "t2.micro" и с использованием образа AMI "ami-201720221991yay".
</b>
</details>

<details>
<summary>Что вы делаете после того, как написали следующее в файле main.tf?

```
resource "aws_instance" "some-instance" {
  ami           = "ami-201720221991yay"
  instance_type = "t2.micro"
}
```
</summary><br><b>

Запустите `terraform init`. Это просканирует код в директории, чтобы выяснить, какие провайдеры используются (в данном случае провайдер AWS) и загрузит их.
</b></details>

<details>
<summary>Вы выполнили <code>terraform init</code>, и теперь хотите перейти к созданию ресурсов, но у вас есть сомнения, и вы хотите быть на 100% уверены в том, что собираетесь выполнить. Что вам следует сделать?</summary><br><b>

Выполните `terraform plan`. Это предоставит детальную информацию о том, что Terraform будет делать, когда вы примените изменения.
</b></details>

<details>
<summary>Вы скачали провайдеров, увидели, что будет делать Terraform (с помощью terraform plan), и теперь готовы применить изменения. Что вам следует сделать дальше?</summary><br><b>

Запустите `terraform apply`. Это применит изменения, описанные в ваших .tf файлах.
</b></details>

<details>
<summary>Объясните значение следующих символов, которые видны в начале каждой строки, когда вы запускаете <code>terraform apply</code>:

* '+'
* '-'
* '-/+'
</summary><br><b>

* '+' — ресурс или атрибут будут добавлены
* '-' — ресурс или атрибут будут удалены
* '-/+' — ресурс или атрибут будут заменены
</b></details>

<details>
<summary>Как удалить ресурсы Terraform? Почему пользователь должен быть осторожен, делая это?</summary><br><b>

`terraform destroy` удалит все ресурсы, отслеживаемые Terraform.

Пользователь должен быть осторожен с этой командой, потому что нет возможности вернуть все назад. Конечно, вы всегда можете снова выполнить "apply", но это может занять время, сгенерирует совершенно новые ресурсы и т. д.
</b></details>

### Зависимости

<details>
<summary>Иногда нужно ссылаться на некоторые ресурсы в одном или отдельном .tf файле. Почему и как это делается?</summary><br><b>

Почему: потому что ресурсы иногда связаны или должны быть связаны. Например, вы создаете экземпляр AWS с ресурсом "aws_instance", но одновременно хотите разрешить ему некоторый трафик (поскольку по умолчанию трафик не разрешен). Для этого вы создадите ресурс "aws_security_group", а затем в ресурсе aws_instance вы на него соссылетесь.

Как:

Используется синтаксис <ПРОВАЙДЕР ТИП>.<ИМЯ>.<АТОИБУТ>

В вашем экземпляре AWS это будет выглядеть так:

```
resource "aws_instance" "some-instance" {

  ami           = "some-ami"
  instance_type = "t2.micro"
  vpc_security_group_ids = [aws_security_group.instance.id]

}
```
</b></details>

<details>
<summary>Имеет ли значение порядок создания ресурсов в Terraform?</summary><br><b>

Да, когда существует зависимость между различными ресурсами Terraform, вы хотите, чтобы ресурсы создавались в правильном порядке, и именно это делает Terraform.

Чтобы сделать это еще более ясным, если у вас есть ресурс X, который ссылается на ID ресурса Y, нет смысла сначала создавать ресурс X, потому что у него не будет никакого ID, откуда взять значение от ресурса, который еще не создан.
</b></details>

<details>
<summary>Существует ли способ напечатать/увидеть зависимости между различными ресурсами?</summary><br><b>

Да, с помощью `terraform graph`.

Вывод находится в формате DOT — языке описания графов.
</b></details>

### Провайдеры

<details>
<summary>Объясните, что такое "провайдер"</summary><br><b>

[terraform.io](https://www.terraform.io/docs/language/providers/index.html): "Terraform полагается на плагины, называемые 'провайдерами', для взаимодействия с облачными провайдерами, провайдерами SaaS и другими API... Каждый провайдер добавляет набор типов ресурсов и/или источников данных, которые Terraform может управлять. Каждый тип ресурса реализован провайдером; без провайдеров Terraform не может управлять ни одним видом инфраструктуры."
</b></details>

<details>
<summary>Где можно найти общедоступные провайдеры?</summary><br><b>

В [Terraform Registry](https://registry.terraform.io/browse/providers).
</b></details>

<details>
<summary>Каковы названия провайдеров в следующем случае?

```
terraform {
    required_providers {
      aws = {
        source  = "hashicorp/aws"
      }
      azurerm = {
        source  = "hashicorp/azurerm"
        version = "~> 3.0.2"
      }
    }
  }
```
</summary><br><b>

azurerm и aws.
</b></details>

<details>
<summary>Как установить провайдер?</summary><br><b>

Вы пишете блок провайдера, подобный следующему, и запускаете `terraform init`.

```
provider "aws" {
  region = "us-west-1"
}
```
</b></details>

<details>
<summary>Правда или ложь? Применение следующей конфигурации Terraform не сработает, так как нет источника или версии для провайдера 'aws'.

```
terraform {
    required_providers {
      aws = {}
    }
  }
```
</summary><br><b>

Ложь. Он будет искать провайдер "aws" в общедоступном реестре Terraform и возьмет последнюю версию.
</b></details>

<details>
<summary>Напишите конфигурацию провайдера Terraform (любой тип, который вам нравится).</summary><br><b>

AWS является одним из самых популярных провайдеров в Terraform. Вот пример того, как его настроить на использование одного конкретного региона и указать конкретную версию провайдера:

```
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.0"
    }
  }
}

# Настройка провайдера AWS
provider "aws" {
  region = "us-west-2"
}
```
</b></details>

<details>
<summary>Откуда по умолчанию Terraform устанавливает провайдеров?</summary><br><b>

По умолчанию провайдеры Terraform устанавливаются из реестра Terraform.
</b></details>

<details>
<summary>Что такое реестр Terraform?</summary><br><b>

Реестр Terraform предоставляет централизованное место для официальных и управляемых сообществом провайдеров и модулей.
</b></details>

<details>
<summary>Куда загружаются провайдеры? (например, когда вы запускаете <code>terraform init</code>)</summary><br><b>

В директорию `.terraform`.
</b></details>

<details>
<summary>Опишите на высоком уровне, что происходит за кулисами, когда вы запускаете terraform init с следующей конфигурацией Terraform.

```
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 3.0"
    }
  }
}
```
</summary><br><b>

1. Terraform проверяет наличие провайдера aws по этому адресу: `registry.terraform.io/hashicorp/aws`.
2. Устанавливает последнюю версию провайдера aws (при условии, что URL существует и действителен).
</b></details>

<details>
<summary>Правда или ложь? Вы можете устанавливать провайдеров только от hashicorp.</summary><br><b>

Ложь. Вы можете указать любой провайдер с любого URL, а не только те, которые от hashicorp.
</b></details>

### Переменные

#### Входные переменные

<details>
<summary>Для чего полезны входные переменные в Terraform?</summary><br><b>

Переменные позволяют вам определить одну часть данных в одном месте, вместо того чтобы повторять жестко закодированные значения в нескольких разных местах. Затем, когда вам нужно изменить значение переменной, вы делаете это в одном месте, вместо того чтобы изменять каждое жестко закодированное значение.
</b></details>

<details>
<summary>Какие типы входных переменных поддерживаются в Terraform?</summary><br><b>

```
string
number
bool
list(<TYPE>)
set(<TYPE>)
map(<TYPE>)
object({<ATTR_NAME> = <TYPE>, ... })
tuple([<TYPE>, ...])
```
</b></details>

<details>
<summary>Какой тип входной переменной является типом по умолчанию в Terraform?</summary><br><b>

`any`
</b></details>

<details>
<summary>Какие есть способы передать значения для входных переменных?</summary><br><b>

* Используя опцию `-var` в CLI
* Используя файл с помощью опции `-var-file` в CLI
* Переменная окружения, начинающаяся с `TF_VAR_<VAR_NAME>`

Если значение не указано, пользователя попросят ввести его.
</b></details>

<details>
<summary>Как сослаться на переменную?</summary><br><b>

Используя синтаксис `var.<VAR_NAME>`.
</b></details>

<details>
<summary>Каков эффект установки переменной как "чувствительной"?</summary><br><b>

Ее значение не покажется, когда вы запускаете `terraform apply` или `terraform plan`, но тем не менее оно все еще записывается в файле состояния.
</b></details>

<details>
<summary>Правда или ложь? Если результат выражения зависит от чувствительной переменной, оно будет также рассматриваться как чувствительное.</summary><br><b>

Правда.
</b></details>

<details>
<summary>Та же переменная определена в следующих местах:

- Файл `terraform.tfvars`
- Переменная окружения
- С использованием `-var` или `-var-file`

Согласно приоритету переменных, какой источник будет использоваться первым?</summary><br><b>

Terraform загружает переменные в следующем порядке, при этом более поздние источники имеют приоритет перед более ранними:

  - Переменная окружения
  - Файл `terraform.tfvars`
  - Используя `-var` или `-var-file`
</b></details>

<details>
<summary>Когда вы каждый раз запускаете terraform apply, он предлагает ввести значение для данной переменной. Как избежать этого запроса?</summary><br><b>

Хотя теоретически правильным ответом будет удалить переменную, это, вероятно, приведет к сбою выполнения.

Вы можете использовать что-то вроде опции `-var`, чтобы предоставить значение и избежать запроса. Другой вариант — запустить `export TF_VAR_<VAR_NAME>=<VALUE>`.
</b></details>

#### Выходные переменные

<details>
<summary>Что такое выходные переменные? Зачем они нужны?</summary><br><b>

Выходные переменные позволяют вам отображать/печать определенный фрагмент данных как часть выполнения Terraform.

Наиболее часто используемый случай — это, вероятно, печать IP-адреса экземпляра. Представьте, что вы развернули экземпляр и хотите узнать, какой IP-адрес использовать для подключения к нему. Вместо того, чтобы искать его в консоли/ОС, вы можете использовать выходную переменную и распечатать эту информацию на экране.
</b></details>

<details>
<summary>Объясните параметр "чувствительный" выходной переменной.</summary><br><b>

Когда он установлен в "true", Terraform будет избегать записи данных выходной переменной в журнал. Случай использования — это чувствительные данные, такие как пароли или личные ключи.
</b></details>

<details>
<summary>Объясните параметр "зависит" выходной переменной.</summary><br><b>

Этот параметр используется для явного установления зависимости между выходной переменной и любым другим ресурсом. Случай использования: некоторая информация доступна только после того, как другой ресурс готов.
</b></details>

#### Локальные переменные

<details>
<summary>Что такое локальные переменные?</summary><br><b>

Подобно переменным, они служат заполнителями для данных и значений. В отличие от переменных, пользователи не могут переопределить их, передавая разные значения.
</b></details>

<details>
<summary>Каков случай использования локальных переменных?</summary><br><b>

У вас есть множество жестко закодированных значений, которые повторяются в разных разделах, но одновременно вы не хотите их раскрывать, позволяя пользователям переопределять значения.
</b></details>

#### Практика с переменными

<details>
<summary>Демонстрация определения входной переменной с типом, описанием и параметрами по умолчанию.</summary><br><b>

```
variable "app_id" {
  type        = string
  description = "Идентификатор приложения"
  default     = "some_value"
}
```

Несвязанная заметка: переменные обычно определяются в собственном файле (например, vars.tf).
</b></details>

<details>
<summary>Как определить входную переменную, которая является объектом с атрибутами "model" (строка), "color" (строка), "year" (число)?</summary><br><b>

```
variable "car_model" {
  description = "Объект модели автомобиля"
  type        = object({
    model   = string
    color   = string
    year    = number
  })
}
```

Примечание: вы также можете определить значение по умолчанию для нее.
</b></details>

<details>
<summary>Как ссылаться на переменные?</summary><br><b>

Переменные ссылаются с помощью синтаксиса `var.VARIABLE_NAME`. Давайте посмотрим на пример:

vars.tf:

```
variable "memory" {
  type = string
  default = "8192"
}

variable "cpu" {
  type = string
  default = "4"
}
```

main.tf:

```
resource "libvirt_domain" "vm1" {
   name = "vm1"
   memory = var.memory
   cpu = var.cpu
}
```
</b></details>

<details>
<summary>Как ссылаться на переменную из строки литерала? (бонусный вопрос: как называется этот тип выражения?)</summary><br><b>

Используя синтаксис: `"${var.VAR_NAME}"`. Это называется "интерполяция".

Очень часто это можно увидеть в атрибутах user_data, связанных с экземплярами.

```
user_data = <<-EOF
            Это какая-то удивительная строка
            Она демонстрирует, как использовать интерполяцию
            Да, это действительно ${var.awesome_or_meh}
            EOF
```
</b></details>

<details>
<summary>Как можно перечислить все выходные переменные без применения изменений в Terraform?</summary><br><b>

`terraform output` перечислит все выходные переменные без применения каких-либо изменений.
</b></details>

<details>
<summary>Можете ли вы увидеть выходные данные определенной переменной без применения изменений в Terraform?</summary><br><b>

Да, с помощью команды `terraform output <OUTPUT_VAR>`.

Очень полезно для сценариев. :)
</b></details>

<details>
<summary>Демонстрация того, как определить локальные переменные.</summary><br><b>

```
locals {
  x = 2
  y = "o"
  z = 2.2
}
```
</b></details>

<details>
<summary>Демонстрация того, как использовать локальную переменную.</summary><br><b>

Если мы определили что-то вроде этого:

```
locals {
  x = 2
}
```

Тогда для ее использования вам нужно использовать что-то вроде `local.x`.
</b></details>

### Источники данных

<details>
<summary>Объясните источники данных в Terraform</summary><br><b>

* Источники данных используются для получения данных от провайдеров или, в общем, от внешних ресурсов в Terraform (например, публичные облака, такие как AWS, GCP, Azure).
* Источники данных используются только для чтения. Они не изменяют и не создают ничего.
* Многие провайдеры предоставляют несколько источников данных.
</b></details>

<details>
<summary>Демонстрация использования источников данных</summary><br><b>

```
data "aws_vpc" "default" {
  default = true
}
```
</b></details>

<details>
<summary>Как извлечь данные из источника данных?</summary><br><b>

Общий синтаксис: `data.<PROVIDER_AND_TYPE>.<NAME>.<ATTRIBUTE>`

Таким образом, если вы определили следующий источник данных:

```
data "aws_vpc" "default" {
  default = true
}
```

Вы можете извлечь атрибут ID следующим образом: `data.aws_vpc.default.id`
</b></details>

<details>
<summary>Существует ли возможность комбинировать источники данных? Каков был бы случай использования?</summary><br><b>

Да, вы можете определить источник данных, используя другой источник данных в качестве фильтра, например.

Допустим, мы хотим получить подсети AWS, но только из нашей основной VPC:

```
data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}
```
</b></details>

### Цикл жизни

<details>
<summary>Как работает обновление ресурса?</summary><br><b>

По умолчанию текущий ресурс сначала удаляется, а затем создается новый, и любые ссылки, указывающие на старый ресурс, обновляются, чтобы указывать на новый ресурс.
</b></details>

<details>
<summary>Возможно ли модифицировать типичный цикл жизни? Как? Почему?</summary><br><b>

Да, это возможно. Существует несколько различных циклов жизни, которые можно выбрать. Например, "create_before_destroy", который изменяет порядок и сначала создает новый ресурс, затем обновляет все ссылки со старого ресурса на новый ресурс и, наконец, удаляет старый ресурс.

Как это использовать:

```
lifecycle {
  create_before_destroy = true
}
```

Почему использовать это в первую очередь: у вас могут быть ресурсы, которые имеют зависимость, где сама зависимость неизменна (вы не можете ее изменить, следовательно, вам нужно создать новый ресурс). В таком случае стандартный цикл жизни не будет работать, поскольку вы не сможете удалить ресурс, у которого есть зависимость, так как он все еще ссылается на старый ресурс. AWS ASG + конфигурации запуска — хороший пример такого случая использования.
</b></details>

<details>
<summary>Вы развернули виртуальную машину с помощью Terraform и хотите передать данные на нее (или выполнить команды). Какой концепцией Terraform вы бы воспользовались?</summary><br><b>

[Провизионеры](https://www.terraform.io/docs/language/resources/provisioners)
</b></details>

### Провизионеры

<details>
<summary>Что такое "провизионеры"? Для чего они используются?</summary><br><b>

Провизионеры можно описать как плагины, которые используются с Terraform, обычно сосредоточенные на аспектах конфигурации сервиса и его операционной готовности.

Некоторые примеры провизионеров:

* Выполнение управления конфигурацией на провизионном экземпляре с помощью таких технологий, как Ansible, Chef или Puppet.
* Копирование файлов.
* Выполнение удаленных скриптов.
</b></details>

<details>
<summary>Почему часто рекомендуется использовать провизионеры в качестве крайней меры?</summary><br><b>

Поскольку провизионер может выполнять различные действия, не всегда возможно заранее спланировать и понять, что произойдет при выполнении определенного провизионера. По этой причине обычно рекомендуется использовать встроенные функции Terraform, когда это возможно.
</b></details>

<details>
<summary>Что такое <code>local-exec</code> и <code>remote-exec</code> в контексте провизионеров?</summary><br><b>

Провизионеры <code>local-exec</code> выполняют команды на машине, где выполняется Terraform, в то время как провизионеры <code>remote-exec</code> выполняют команды на удаленном ресурсе.
</b></details>

<details>
<summary>Что такое "помеченный ресурс"?</summary><br><b>

Это ресурс, который был успешно создан, но не удался во время провизии. Terraform неудачно завершит работу и пометит этот ресурс как "помеченный".
</b></details>

<details>
<summary>Что делает <code>terraform taint</code>?</summary><br><b>
<code>terraform taint resource.id</code> вручную помечает ресурс как помеченный в файле состояния. Таким образом, когда вы в следующий раз выполняете <code>terraform apply</code>, ресурс будет уничтожен и воссоздан.
</b></details>

<details>
<summary>Что такое источник данных? В каких сценариях, например, вам может понадобиться его использовать?</summary><br><b>
Источники данных выполняют поиск или вычисление значений, которые могут быть использованы в других местах в конфигурации Terraform.

Существует довольно много случаев, когда вам может понадобиться использовать их:
* вы хотите сослаться на ресурсы, не управляемые через Terraform
* вы хотите сослаться на ресурсы, управляемые другим модулем Terraform
* вы хотите аккуратно вычислить значение с проверкой типов, например с использованием <code>aws_iam_policy_document</code>
</b></details>

<details>
<summary>Что такое выходные переменные и что делает <code>terraform output</code>?</summary><br><b>
Выходные переменные — это именованные значения, которые берутся из атрибутов модуля. Они хранятся в состоянии Terraform и могут использоваться другими модулями через <code>remote_state</code>.
</b></details>

<details>
<summary>Объясните "удаленное состояние". Когда и как бы вы его использовали?</summary><br><b>
Terraform генерирует файл `terraform.tfstate` в формате JSON, который описывает компоненты/сервисы, развернутые на указанном провайдере. Удаленное состояние хранит этот файл в удаленном хранилище для обеспечения совместной работы в команде.
</b></details>

<details>
<summary>Объясните "блокировка состояния"</summary><br><b>
Блокировка состояния — это механизм, который блокирует операции над конкретным файлом состояния от нескольких вызывающих, чтобы избежать конфликтующих операций от разных членов команды. Как только блокировка операции первого вызывающего освободится, другой член команды может продолжать выполнять свою операцию. Тем не менее, Terraform сначала проверит файл состояния, чтобы увидеть, существует ли уже желаемый ресурс, и если нет, то перейдет к его созданию.
</b></details>

<details>
<summary>Кроме файлов <code>.tfvars</code> или аргументов CLI, как вы можете вводить зависимости из других модулей?</summary><br><b>
Встроенный способ Terraform заключается в использовании <code>remote-state</code> для поиска выходных переменных из других модулей. Также в сообществе распространено использование инструмента под названием <code>terragrunt</code> для явного внесения переменных между модулями.
</b></details>

<details>
<summary>Как импортировать существующий ресурс с помощью Terraform import?</summary><br><b>

1. Определите, какой ресурс вы хотите импортировать.
2. Напишите код Terraform, который соответствует конфигурации этого ресурса.
3. Выполните команду Terraform <code>terraform import RESOURCE ID</code><br>

Например, предположим, что вы хотите импортировать экземпляр AWS. Тогда вам нужно выполнить следующие шаги:
1. Найдите экземпляр AWS в консоли.
2. Обратитесь к его конфигурации и напишите код Terraform, который будет выглядеть примерно так:
```
resource "aws_instance" "tf_aws_instance" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"

  tags = {
    Name = "import-me"
  }
}
```
3. Выполните команду Terraform <code>terraform import aws_instance.tf_aws_instance i-12345678</code>
</b></details>


### Состояние

<details>
<summary>Что такое состояние Terraform?</summary><br><b>

[terraform.io](https://www.terraform.io/language/state): "Terraform должен хранить состояние о вашей управляемой инфраструктуре и конфигурации. Это состояние используется Terraform для сопоставления реальных ресурсов с вашей конфигурацией, отслеживания метаданных и повышения производительности для больших инфраструктур."

Другими словами, это механизм в Terraform для отслеживания ресурсов, которые вы создали или очистили. Так Terraform знает, что обновить, создать или удалить, когда вы выполняете <code>terraform apply</code>, а также при выполнении других команд, таких как <code>terraform destroy</code>.
</b></details>

<details>
<summary>Где хранится состояние Terraform?</summary><br><b>

На этот вопрос есть не один ответ. Это сильно зависит от того, делитесь ли вы состоянием с другими или оно только локально в вашей директории Terraform. Но в случае новичка, когда вы запускаете Terraform в директории, состояние будет храниться в этой директории в файле `terraform.tfstate`.
</b></details>

<details>
<summary>Можете ли вы назвать три разные вещи, включенные в файл состояния?</summary><br><b>

* Представление ресурсов — JSON-формат ресурсов, их атрибутов, ID и всего, что необходимо для идентификации ресурса, а также всего, что было включено в .tf файлы для этих ресурсов.
* Версия Terraform.
* Выходные данные.
</b></details>

<details>
<summary>Почему важно, где вы храните файл tfstate? В вашем ответе обязательно укажите следующие аспекты:

* Публичный vs. Приватный
* Репозиторий Git vs. Другие места
</summary><br><b>

- tfstate содержит учетные данные в открытом виде. Вы не хотите размещать его в общедоступном месте.
- tfstate не должен изменяться одновременно, поэтому размещение его в общедоступном месте с правами "записи" для всех может привести к проблемам. (Удаленное состояние Terraform не имеет этой проблемы).
- tfstate — важный файл. Поэтому лучше всего хранить его в месте, которое имеет регулярные резервные копии и хорошую безопасность.

Поэтому tfstate не следует хранить в репозиториях Git. Хранение в защищенных хранилищах, таких как защищенные корзины, является более хорошим вариантом.
</b></details>

<details>
<summary>Правда или ложь? Обычно целесообразно изменять файл состояния Terraform напрямую и даже рекомендуется для множества различных случаев использования.</summary><br><b>

Ложь. Вам следует как можно больше избегать ручного редактирования файлов состояния Terraform.
</b></details>

<details>
<summary>Почему хранение файла состояния локально на вашем компьютере может быть проблематичным?</summary><br><b>

В общем, хранение файла состояния на вашем компьютере не является проблемой. Проблема возникает, когда вы являетесь частью команды, использующей Terraform, и хотите убедиться, что он совместно используется. В дополнение к совместному использованию, вы хотите обеспечить возможность обработки факта, что разные члены команды могут редактировать файл одновременно, поэтому блокировка состояния также является важным аспектом.
</b></details>

<details>
<summary>Упомяните некоторые лучшие практики, связанные с tfstate</summary><br><b>

  - Не редактируйте его вручную. tfstate был разработан для манипуляций с помощью Terraform, а не непосредственно пользователями.
  - Храните его в защищенном месте (так как он может включать учетные данные и чувствительные данные).
  - Регулярно создавайте резервные копии, чтобы вы могли легко восстановиться при необходимости.
  - Храните его в удаленном совместном хранилище. Это особенно необходимо при работе в команде, когда состояние может быть обновлено любым из членов команды.
  - Включите версионирование, если хранилище, в котором вы храните файл состояния, поддерживает его. Версионирование отлично подходит для резервного копирования и восстановления в случае проблем.
</b></details>

<details>
<summary>Как и почему следует избегать одновременных правок файла состояния?</summary><br><b>

Если два пользователя или процесса одновременно редактируют файл состояния, это может привести к недействительному файлу состояния, который на самом деле не представляет состояние ресурсов.<br>

Чтобы избежать этого, Terraform может применить блокировку состояния, если бэкэнд это поддерживает. Например, AWS S3 поддерживает блокировку состояния и согласованность через DynamoDB. Часто, если бэкэнд это поддерживает, Terraform автоматически использует блокировку состояния, так что от пользователя не требуется никаких действий для ее активации.
</b></details>

<details>
<summary>Опишите, как вы управляете файлами состояния, когда у вас есть несколько окружений (например, разработка, предварительная проверка и продукция).</summary><br><b>

Вероятно, здесь нет правильного или неправильного ответа, но, судя по различным источникам, общий предпочтительный способ — иметь отдельный файл состояния на каждое окружение.
</b></details>

<details>
<summary>Почему хранение состояния в репозитории с контролем версий — это плохая идея?</summary><br><b>

* Чувствительные данные: некоторые ресурсы могут содержать чувствительные данные (например, пароли и токены), и вся информация в файле состояния хранится в открытом виде.
* Подверженность ошибкам: при работе с репозиториями Git вы можете часто переключать ветки, проверять конкретные коммиты, выполнять слияния и т.д. Все эти операции могут в конечном итоге привести к выполнению <code>terraform apply</code> на не последней версии вашего кода Terraform.
</b></details>

#### Backend Terraform

<details>
<summary>Что такое backend Terraform? Какой backend является стандартным?</summary><br><b>

Backend Terraform определяет, как хранится и загружается состояние Terraform. По умолчанию состояние локальное, но можно настроить удалённый backend.
</b></details>

<details>
<summary>Опишите, как настроить удалённый backend любого типа по вашему выбору</summary><br><b>

Рассмотрим случай, когда мы выбрали Amazon S3 в качестве удалённого backend Terraform для хранения состояния Terraform.

1. Напишите код Terraform для создания бакета S3.
   1. Было бы разумно добавить жизненный цикл с "prevent_destroy", чтобы его случайно не удалить.
2. Включите версионирование (добавьте ресурс "aws_s3_bucket_versioning").
3. Защитите бакет (используя "aws_s3_bucket_server_side_encryption_configuration").
4. Заблокируйте публичный доступ.
5. Обеспечьте блокировку. Один из способов - добавить для этого базу данных.
6. Укажите точку, когда вы хотите выполнить команды init и apply, чтобы избежать проблемы, когда одновременно создаются ресурсы для удаленного backend и одновременно переключаетесь на удалённый backend.
7. После создания ресурсов добавьте код backend Terraform:

```
terraform {
  backend "s3" {
    bucket ...
  }
}
```

8. Выполните `terraform init`, так как это настроит backend.
</b></details>

<details>
<summary>Какова разница в процессе работы <code>terraform apply</code>, когда используется удалённый backend?</summary><br><b>

Процесс начинается с блокировки состояния, чтобы другие пользователи не могли одновременно изменять состояние.
</b></details>

<details>
<summary>Каков процесс переключения назад с удалённого backend на локальный?</summary><br><b>

1. Удалите код backend и выполните `terraform init`, чтобы переключиться обратно на локальный backend.
2. Удалите ресурсы, которые являются самим удалённым backend.
</b></details>

<details>
<summary>Правда или ложь? Нельзя использовать переменные в настройках backend</summary><br><b>

Это правда, и это довольно серьезное ограничение, так как это означает, что вам придется переходить к ресурсам удаленного backend и копировать некоторые значения в конфигурацию backend.

Один из способов справиться с этим - использовать частичные конфигурации в совершенно отдельном файле от самого backend и затем загружать их с помощью `terraform init -backend-config=some_backend_partial_conf.hcl`.
</b></details>

<details>
<summary>Есть ли способ получить информацию из удаленного backend/состояния с помощью Terraform?</summary><br><b>

Да, с помощью концепции источников данных. Есть источник данных для удалённого состояния, называемый "terraform_remote_state".

Вы можете использовать его с помощью следующего синтаксиса: `data.terraform_remote_state.<NAME>.outputs.<ATTRIBUTE>`.
</b></details>

#### Рабочие пространства

<details>
<summary>Объясните, что такое рабочее пространство Terraform</summary><br><b>

[developer.hashicorp.com](https://developer.hashicorp.com/terraform/language/state/workspaces): "Постоянные данные, хранящиеся в backend, принадлежат рабочему пространству. Изначально backend имеет только одно рабочее пространство, содержащее одно состояние Terraform, связанное с этой конфигурацией. Некоторые backend поддерживают несколько именованных рабочих пространств, позволяя ассоциировать несколько состояний с одной конфигурацией."
</b></details>

<details>
<summary>Правда или ложь? У каждого рабочего пространства есть свой файл состояния</summary><br><b>

Правда
</b></details>

<details>
<summary>Почему рабочие пространства могут не быть лучшим решением для управления состоянием для различных окружений, таких как подготовка и продукция?</summary><br><b>

Одной из причин является то, что все рабочие пространства хранятся в одном месте (в одном backend), и обычно вы не хотите использовать одинаковые контроллеры доступа и аутентификацию для подготовки и продукции по очевидным причинам. Кроме того, работа в рабочих пространствах довольно подвержена человеческим ошибкам, так как вы можете случайно подумать, что находитесь в одном рабочем пространстве, в то время как работаете в совершенно другом.
</b></details>


#### Практические задания по состоянию

<details>
<summary>Какая команда создаст файл состояния?</summary><br><b>

`terraform apply`
</b></details>

<details>
<summary>Как просмотреть текущее состояние?</summary><br><b>

`terraform show`
</b></details>

<details>
<summary>Как перечислить ресурсы, созданные с помощью Terraform?</summary><br><b>

`terraform state list`
</b></details>

<details>
<summary>Как переименовать существующий ресурс?</summary><br><b>

`terraform state mv`
</b></details>

<details>
<summary>Как создать новое рабочее пространство?</summary><br><b>

`terraform workspace new <WORKSPACE_NAME>`
</b></details>

<details>
<summary>Как определить, какое рабочее пространство вы используете?</summary><br><b>

`terraform workspace show`
</b></details>

### Структуры и синтаксис Terraform

#### Списки

<details>
<summary>Как определить входную переменную, которая является списком чисел?</summary><br><b>

```
variable "list_of_nums" {
  type = list(number)
  description = "Пример списка чисел"
  default = [2, 0, 1, 7]
}
```
</b></details>

<details>
<summary>Как создать количество ресурсов на основе длины списка?</summary><br><b>

```
resource "some_resource" "some_name" {
  count = length(var.some_list)
}
```
</b></details>

<details>
<summary>У вас есть переменная списка "users", содержащая объект с атрибутом name следующим образом:<br>

```
variable "users" {
  type = list(object({
    name = string
    age  = number
  }))
}
```

Как получить доступ к атрибуту name второго элемента в этом списке?</summary><br><b>

`users[1].name`
</b></details>

<details>
<summary>Учитывая тот же список, как получить доступ к атрибуту "name" всех элементов?</summary><br><b>

`users[*].name`
</b></details>

#### Циклы

<details>
<summary>Для чего полезны циклы в Terraform?</summary><br><b>

Наиболее распространенный случай использования - это создание нескольких ресурсов с небольшими изменениями (например, с разными именами). Вместо того чтобы определять несколько отдельных ресурсов, вы можете определить один раз и создать несколько экземпляров, используя циклы.
</b></details>

<details>
<summary>Демонстрация, как определить простой цикл в Terraform</summary><br><b>

```
resource "aws_instance" "server" {
  count = 15
}
```

Данная конфигурация создаст 15 экземпляров AWS.
</b></details>

<details>
<summary>Как создать несколько экземпляров AWS, но с разными именами?</summary><br><b>

```
resource "aws_instance" "server" {
  count = 6

  tags = {
    Name = "instance-${count.index}"
  }
}
```

Данная конфигурация создаст 6 экземпляров, каждый с разным именем.
</b></details>

<details>
<summary>У вас есть следующая переменная, определенная в Terraform

```
variable "users" {
  type    = list(string)
  default = ["mario", "luigi", "peach"]
}
```

Как использовать её для создания пользователей в одном из публичных облаков (или на любой другой платформе)?</summary><br><b>

```
resource "aws_iam_user" "user" {
  count = length(var.users)

  name = var.users[count.index]
}
```
</b></details>

<details>
<summary>Существует ли какое-либо ограничение для мета-аргумента "count"?</summary><br><b>

* `count` не поддерживается внутри встроенного блока.
* Он довольно ограничен, когда дело касается списков. Вы заметите, что изменение элементов в списках или даже операции такие, как удаление, иногда интерпретируются не так, как вы ожидали. Например, удаление элемента из списка может сместить другие элементы на новые позиции, и поскольку каждая позиция соответствует ресурсу с count, это может привести к тому, что неправильные ресурсы будут изменены и удалены. Существуют способы справиться с этим, но использование count со списками не всегда является простым.
</b></details>

<details>
<summary>Что такое цикл for_each? Чем он отличается от "count"?</summary><br><b>

* for_each может применяться только к коллекциям, таким как карты или множества (в отличие от count, который может применяться к спискам).
* for_each помогает справиться с ограничениями `count`, которые не являются оптимальными для случаев изменения списков.
* for_each поддерживает встроенные блоки, в отличие от `count`.
</b></details>

<details>
<summary>Демонстрация использования цикла for_each</summary><br><b>

```
resource “google_compute_instance” “instances” {

  for_each = var.names_map
  name = each.value
}
```
</b></details>

<details>
<summary>Следующий ресурс пытается использовать цикл for_each на списке строк, но он не удался, почему?

```
resource “google_compute_instance” “instances” {

  for_each = var.names
  name = each.value
}
```
</summary><br><b>

Цикл for_each может применяться только к коллекциям, таким как карты или множества, поэтому список следует преобразовать в множество так: `for_each = toset(var.names)`.
</b></details>

<details>
<summary>Как использовать цикл for_each для встроенных блоков?</summary><br><b>

```
resource "some_instance" "instance" {

dynamic "tag" {
  for_each = var.tags

  content {
    key   = tag.key
    value = tag.value
    }
  }
}
```
</b></details>

<details>
<summary>Существует переменная списка, называемая "users". Вы хотите определить выходную переменную со значением всех пользователей в верхнем регистре. Как это сделать?</summary><br><b>

```
output "users" {
  value = [for name in var.user_names : upper(name)]
}
```
</b></details>

<details>
<summary>Каков результат следующего кода?

```
resource "random_integer" "num" {
  min = 20
  max = 17
}

resource "aws_instance" "instances" {
  count = random_integer.num.results
}
```
</summary><br><b>

Указанный код завершится ошибкой, так как нельзя ссылаться на выходы ресурсов с count, так как Terraform должен вычислить count перед созданием (или изменением) любых ресурсов.
</b></details>

<details>
<summary>Есть переменная "values" со следующим значением: ["mario", "luigi", "peach"]. Как создать выходную переменную со строковым значением элементов списка: "mario, luigi, peach,"?</summary><br><b>

```
output "users" {
  value = "%{ for name in var.values }${name}, %{ endfor }"
}
```
</b></details>

<details>
<summary>Существует переменная списка, называемая "users". Вы хотите определить выходную переменную со значением всех пользователей в верхнем регистре, но только если имя длиннее 3 символов. Как это сделать?</summary><br><b>

```
output "users" {
  value = [for name in var.user_names : upper(name) if length(name) > 3]
}
```
</b></details>

#### Карты

<details>
<summary>Есть карта "instances".

* Как извлечь только значения этой карты?
* Как извлечь только атрибут "name" из каждого значения?
</summary><br><b>

* Используя встроенную функцию values: `values(instances)`
* `values(instances)[*].name`
</b></details>

<details>
<summary>У вас есть переменная карты, называемая "users", с ключами "name" и "age". Определите выходную переменную списка со значением "меня зовут {name}, и мне {age} лет."</summary><br><b>

```
output "name_and_age" {
  value = [for name, age in var.users : "меня зовут ${name}, и мне ${age} лет."]
}
```
</b></details>

<details>
<summary>У вас есть переменная карты, называемая "users", с ключами "name" (строка) и "age" (число). Определите выходную переменную карты, где ключ — это имя в верхнем регистре, а значение — возраст, округленный до ближайшего целого числа.</summary><br><b>

```
output "name_and_age" {
  value = {for name, age in var.users : upper(name) => floor(age)}
}
```
</b></details>

#### Условные выражения

<details>
<summary>Как использовать условные выражения в Terraform?</summary><br><b>

`some_condition ? "value_if_true" : "value_if_false"`
</b></details>

<details>
<summary>Объясните следующее условие: <code>var.x ? 1 : 0</code></summary><br><b>

Если `x` оценивается как true, то результат 1, иначе (если false) результат 0.
</b></details>

<details>
<summary>Объясните следующее условие: <code>var.x != "" ? var.x : "yay"</code></summary><br><b>

Если `x` — пустая строка, то результат будет "yay", в противном случае — значение переменной `x`.
</b></details>

<details>
<summary>Можно ли использовать условные выражения с мета-аргументами?</summary><br><b>

Да, например с мета-аргументом "count":

```
resource "aws_instance" "server" {
  count = var.amount ? 1 : 0
  ...
}
```
</b></details>

<details>
<summary>Возможно ли комбинировать условные выражения и циклы?</summary><br><b>

Да, например:

```
dynamic "tag" {
  for_each = {
    for key, value in var.tags:
    key => value
    if key != ""
  }
}
```
</b></details>

#### Разное

<details>
<summary>Что такое мета-аргументы в Terraform?</summary><br><b>

Аргументы, которые влияют на жизненный цикл ресурсов (их создание, изменение и т. д.) и поддерживаются Terraform независимо от типа ресурса, в котором они используются.

Некоторые примеры:

* count: сколько ресурсов создать из одного определения ресурса.
* lifecycle: как обрабатывать создание или удаление ресурса.
</b></details>

<details>
<summary>Какие мета-аргументы вам известны?</summary><br><b>

* count: сколько ресурсов создать из одного определения ресурса.
* lifecycle: как обрабатывать создание или удаление ресурса.
* depends_on: создать зависимость между ресурсами.
</b></details>

<details>
<summary>Что делает функция <code>templatefile</code>?</summary><br><b>

Создаёт файл шаблона и возвращает результат в виде строки.
</b></details>

<details>
<summary>Вы пытаетесь использовать templatefile как часть модуля и используете относительный путь для загрузки файла, но иногда это не срабатывает, особенно когда другие пытаются повторно использовать модуль. Как вы можете с этим справиться?</summary><br><b>

Замените относительные пути на то, что называется ссылками на пути. Это исправления: пути, такие как путь к корню модуля, путь к файлу выражения модуля и т. д.
</b></details>

<details>
<summary>Как вы тестируете синтаксис Terraform?</summary><br><b>

Правильный ответ может быть "Я пишу конфигурацию Terraform и пытаюсь выполнить её", но это делает тестирование громоздким и довольно сложным в целом.

Есть команда `terraform console`, которая позволяет легко выполнять функции Terraform и экспериментировать с общим синтаксисом.
</b></details>

<details>
<summary>Правда или ложь? Terraform console следует использовать осторожно, так как она может изменить ваши ресурсы.</summary><br><b>

Ложь. Terraform console только для чтения.
</b></details>

<details>
<summary>Вам нужно отрендерить шаблон и получить его в виде строки. Какой функцию вы бы использовали?</summary><br><b>

Функцию `templatefile`.
</b></details>

<details>
<summary>Объясните, для чего используется <code>depends_on</code> и приведите пример.</summary><br><b>

`depends_on` используется для создания явной зависимости между ресурсами в Terraform. Например, есть приложение, которое вы хотите развернуть в кластере. Если кластер не готов (и также управляется Terraform, конечно), то вы не сможете развернуть приложение. В этом случае вы определите "depends_on" в конфигурации приложения, а его значение будет ресурсом кластера.
</b></details>

### Модули

<details>
<summary>Объясните модули.</summary><br><b>

[Terraform.io](https://www.terraform.io/language/modules/develop): "Модуль — это контейнер для нескольких ресурсов, которые используются вместе. Модули могут быть использованы для создания легковесных абстракций, чтобы описывать вашу инфраструктуру в терминах её архитектуры, а не непосредственно в терминах физических объектов."

Кроме того, модули отлично подходят для создания многократно используемого кода Terraform, который может быть распределён и использован не только между различными репозиториями, но даже внутри одного репозитория, между разными окружениями (такими как предварительная проверка и продукция).
</b></details>

<details>
<summary>Что делает модуль кода Terraform? Другими словами, что такое модуль с практической точки зрения?</summary><br><b>

По сути, любой файл или файлы в директории являются модулем в Terraform. Нет специального синтаксиса, чтобы объявить модуль.
</b></details>

<details>
<summary>Как протестировать модуль Terraform?</summary><br><b>

Существует множество ответов, но самый распространённый ответ, вероятно, будет использованию инструмента <code>terratest</code> для проверки, что модуль может быть инициализирован, может создавать ресурсы и может правильно удалять эти ресурсы.
</b></details>

<details>
<summary>Когда вы создаете модуль, вы предпочитаете использовать встроенные блоки, отдельные ресурсы или оба? Почему?</summary><br><b>

Здесь нет правильного или неправильного ответа.

Лично я предпочитаю использовать только отдельные ресурсы в модулях, так как это делает модули более гибкими. Если ресурс включает встроенные блоки, это может ограничить вас в какой-то момент.
</b></details>

<details>
<summary>Правда или ложь? Исходный код модуля может быть только локальным путем.</summary><br><b>

Ложь. Это может быть URL-адрес Git, HTTP URL и т.д. Например:

```
module "some_module" {

  source = "github.com/foo/modules/bar?ref=v0.1"
}
```
</b></details>

<details>
<summary>Где можно получить модули Terraform?</summary><br><b>

Модули Terraform можно найти в [реестре Terraform](https://registry.terraform.io/browse/modules).
</b></details>

<details>
<summary>Вы заметили, что в некоторых ваших модулях есть относительные пути, и вы хотите это изменить. Что вы можете сделать и почему это проблема изначально?</summary><br><b>

Относительные пути обычно работают нормально в вашей среде, так как вы знакомы с макетом и используемыми путями, но при совместном использовании модуля и его повторного использования вы можете столкнуться с проблемами, поскольку это запускается в разных средах, где относительные пути могут больше не быть актуальными.

Лучший подход — использовать `path reference` в качестве одного из следующих:

* `path.module`: путь к модулю, в котором используется выражение.
* `path.cwd`: путь текущего рабочего каталога.
* `path.root`: путь к корневому модулю.
</b></details>

#### Практические задания по модулям

<details>
<summary>Как использовать модуль?</summary><br><b>

Общий синтаксис:

```
module "<MODULE_NAME>" {
  source = "<MODULE_SOURCE>"

  ...
}
```

Критическая часть — это источник, который вы используете для указания Terraform, где можно найти модуль.
</b></details>

<details>
<summary>Демонстрация использования модуля под названием "amazing_module" в пути "../modules/amazing-module"</summary><br><b>

```
module "amazing_module" {
  source = "../modules/amazing-module"
}
```
</b></details>

<details>
<summary>Что должно быть сделано каждый раз, когда вы изменяете параметр source модуля?</summary><br><b>

Необходимо выполнить `terraform get -update`, так как это позаботится о загрузке и установке модуля из нового пути.
</b></details>

<details>
<summary>Как получить доступ к выходным переменным модуля?</summary><br><b>

Общий синтаксис: `module.<MODULE_NAME>.<OUTPUT_VAR_NAME>`
</b></details>

<details>
<summary>Вы хотите загрузить и отрендерить файл из директории модуля. Как это сделать?</summary><br><b>

script = templatesfile("${path.module}/user-data.sh", {
  ...
})
</b></details>

<details>
<summary>Есть модуль для создания вычислительного экземпляра. Как использовать модуль для создания трех отдельных экземпляров?</summary><br><b>

Начиная с Terraform 0.13, мета-аргумент `count` может использоваться с модулями. Так что вы можете использовать что-то вроде следующего:

```
module "instances" {
  source = "/some/module/path"

  count = 3
}
```

Вы также можете использовать это в выходных переменных: `value = module.instances[*]`.
</b></details>

### Импорт

<details>
<summary>Объясните функциональность импорта Terraform</summary><br><b>

`terraform import` — это команда CLI, используемая для импорта существующей инфраструктуры в состояние Terraform.

Это не создаёт определения/конфигурацию для создания такой инфраструктуры.
</b></details>

<details>
<summary>Назовите два случая использования, когда вы бы использовали <code>terraform import</code></summary><br><b>

1. У вас есть существующие ресурсы в одном из провайдеров, и они не управляются Terraform (как в случае отсутствия в состоянии).
2. Вы потеряли файл tfstate и вам нужно его восстановить.
</b></details>

### Контроль версий

<details>
<summary>У вас есть Git-репозиторий с файлами Terraform, но нет .gitignore. Что бы вы добавили в файл .gitignore в репозитории Terraform?</summary><br><b>

```
**/.terraform/*
*.tfstate
*.tfstate.*
*.tfvars
*.tfvars.json
```

Вы не хотите хранить файл состояния или любые загруженные провайдеры в директории .terraform. Также не имеет смысла делиться/хранить резервные файлы состояния.
</b></details>

### AWS

<details>
<summary>What happens if you update user_data in the following case and apply the changes?

```
resource "aws_instance" "example" {
 ami = "..."
 instance_type = "t2.micro"

 user_data = <<-EOF
             #!/bin/bash
             echo "Hello, World" > index.xhtml
 EOF
}
```
</summary><br><b>

Nothing, because user_data is executed on boot so if an instance is already running, it won't change anything.

To make it effective you'll have to use `user_data_replace_on_change = true`.

</b></details>

<details>
<summary>You manage ASG with Terraform which means you also have "aws_launch_configuration" resources. The problem is that launch configurations are immutable and sometimes you need to change them. This creates a problem where Terraform isn't able to delete ASG because they reference old launch configuration. How to do deal with it?</summary><br><b>

Add the following to "aws_launch_configuration" resource

```
lifecycle {
  create_before_destroy = true
}
```

This will change the order of how Terraform works. First it will create the new resource (launch configuration). then it will update other resources to reference the new launch configuration and finally, it will remove old resources

</b></details>

<details>
<summary>How to manage multiple regions in AWS provider configuration?</summary><br><b>

```
provider "aws" {
  region = "us-west-1"
  alias = "west_region"
}

provider "aws" {
  region = "us-east-1"
  alias = "east_region"
}

data "aws_region" "west_region" {
  provider = aws.west_region
}

data "aws_region" "east_region" {
  provider = aws.east_region
}
```

To use it:

```
resource "aws_instance" "west_region_instance" {
  provider = aws.west_region
  instance_type = "t2.micro"
  ...
}
```

</b></details>

<details>
<summary>Assuming you have multiple regions configured and you would like to use a module in one of them. How to achieve that?</summary><br><b>

```
module "some_module" {
  source = "..."

  providers = {
    aws = aws.some_region
  }

  ...
}
```

</b></details>

<details>
<summary>How to manage multiple AWS accounts?</summary><br><b>

One way is to define multiple different provider blocks, each with its own "assume_role"

```
provider "aws" {
  region = "us-west-1"
  alias = "some-region"

  assume_role {
    role_arn = "arn:aws:iam::<SOME_ACCOUNT_ID>:role/<SOME_ROLE_NAME>"
  }
}
```

</b></details>

### Валидации

<details>
<summary>Как вы можете заставить пользователей, использующих ваши переменные, предоставлять значения с определёнными ограничениями? Например, число больше 1</summary><br><b>

Используя блок `validation`

```
variable "some_var" {
  type = number

  validation {
    condition = var.some_var > 1
    error_message = "вы должны указать число больше 1"
  }
}
```

</b></details>

### Секреты

<details>
<summary>В чём проблема следующей конфигурации провайдера?

```
provider "aws" {
  region = "us-west-1"

  access_key = "blipblopblap"
  secret_key = "bipbopbipbop"
}
```
</summary><br><b>

Это небезопасно! Никогда не храните учётные данные в открытом виде таким образом.

</b></details>

<details>
<summary>Что вы можете сделать, чтобы НЕ хранить учётные данные провайдера в текстовых файлах конфигурации Terraform?</summary><br><b>

1. Используйте переменные среды
2. Используйте CLI для паролей (например, 1Password, который является универсальным, но также есть конкретные варианты для провайдеров, такие как aws-vault)

</b></details>

<details>
<summary>Как вы можете управлять секретами/учётными данными в CI/CD?</summary><br><b>

Это во многом зависит от используемой системы/платформы CI/CD.

- GitHub Actions: Используйте Open ID Connect (OIDC) для установления соединения с вашим провайдером. Затем вы можете указать в вашем workflow GitHub Actions следующее:

```
- uses: aws-actions/configure-aws-credentials@v1
  with:
    role-to-assume: arn:aws:iam::someIamRole
    aws-region: ...
```

- Jenkins: Если Jenkins работает на провайдере, вы можете использовать сущности доступа провайдера (такие как роли, политики и т.д.), чтобы предоставить экземпляру, на котором работает Jenkins, контроль доступа.
- CircleCI: вы можете использовать `CircleCI Context` и затем указать его в вашем файле конфигурации CircleCI.

```
context:
- some-context
```

</b></details>

<details>
<summary>Каковы плюсы и минусы использования переменных среды для управления секретами в конфигурациях Terraform?</summary><br><b>

Плюсы:
 * Вы избегаете использования секретов напрямую в конфигурациях в открытом виде.
 * Бесплатно (не нужно платить за платформы/решения для управления секретами).
 * Простой в использовании.

Минусы:
  * Конфигурации могут не работать без переменных среды, что может влиять на пользовательский опыт, поскольку пользователю необходимо знать, какие переменные среды он должен передавать, чтобы всё работало правильно.
  * В основном управляются вне механизма Terraform, что затрудняет принуждение, отслеживание и т.д. всего, что касается секретов, когда это зависит от пользователя, передающего переменные среды.

</b></details>

<details>
<summary>Правда или ложь? Если вы передаете секреты с помощью переменных среды, они не видны в вашем файле состояния</summary><br><b>

Ложь. Файлы состояния включают чувствительные данные такими, какие они есть. Это означает, что очень важно, чтобы куда бы вы ни хранили свой файл состояния, он был зашифрован и доступен только тем, кто должен иметь к нему доступ.

</b></details>

<details>
<summary>Правда или ложь? Если вы передаете секреты из централизованного хранилища секретов (например, Hashicorp Vault), они не видны в планах (terraform plan)</summary><br><b>

Ложь. Не имеет значения, где хранится ваш секрет (файл, переменные среды, централизованное хранилище секретов), они будут видны как в файле состояния, так и в выводе плана.

</b></details>

### Производство

Этот раздел посвящён тому, как Terraform используется в реальных сценариях и организациях.

<details>
<summary>Каковы структура и разметка ваших проектов?</summary><br><b>

Нет правильного или неправильного ответа, лишь то, что вы лично приняли или ваша команда, и возможность объяснить, почему.

Одним из распространённых подходов является наличие отдельной директории для каждого окружения.

```
terraform_project/
  staging/
  production/
```

Каждое окружение имеет свой собственный backend (поскольку вы не хотите использовать одинаковые аутентификацию и контроль доступа для всех окружений).

Далее, под каждым окружением вы разделяете компоненты, приложения и службы.

```
terraform_project/
  staging/
    applications/
      some-app-service-1/
      some-app-service-2/
    databases/
      mongo/
      postgres/
    networking/
```
</b></details>

<details>
<summary>Какие файлы у вас есть в ваших проектах Terraform?</summary><br><b>

Снова, нет правильного или неправильного ответа. Просто ваш личный опыт.

main.tf
providers.tf
outputs.tf
variables.tf
dependencies.tf

Каждый из этих файлов можно разбить на более мелкие части, если это необходимо (нет причин поддерживать ОЧЕНЬ длинные файлы).

</b></details>

<details>
<summary>Инженер вашей команды жалуется на необходимость много копировать и вставлять код между разными папками и файлами Terraform. Что бы вы сделали?</summary><br><b>

Предложите использовать модули Terraform.

</b></details>

<details>
<summary>При работе с вложенной структурой из множества директорий может быть сложно выполнять команды Terraform во многих различных папках. Как с этим справиться?</summary><br><b>

Существует несколько способов решить эту проблему:
1. Напишите скрипты, которые выполняют некоторые команды рекурсивно с разными условиями.
2. Используйте инструменты, такие как Terragrunt, где вы можете выполнять команды, такие как "run-all", которые могут выполняться параллельно в нескольких различных путях.

</b></details>

<details>
<summary>Один из инженеров вашей команды жалуется, что встроенные оболочки скриптов довольно большие, и их поддержка в файлах Terraform кажется плохой идеей. Что бы вы сделали?</summary><br><b>

Хорошим решением, чтобы не включать оболочные скрипты инлайн (т.е. в конфигурационные файлы Terraform), является хранение их в отдельном файле и затем использование функции Terraform `templatefile` для рендеринга и получения их в виде строки.

</b></details>

<details>
<summary>Вы заметили, что много вашего кода/конфигурации Terraform дублируется, как между репозиториями, так и внутри одного репозитория между разными директориями. Какой один из способов, который вы можете использовать, чтобы упростить это?</summary><br><b>

Использование модулей Terraform может значительно помочь с дублированным кодом, так что различные окружения, например (стадирование и продукция), могут повторно использовать один и тот же код, используя одни и те же модули.

</b></details>

<details>
<summary>Вы заметили, что в вашем коде Terraform довольно много закодированных значений (таких как порты, подсети и т.д.), и они дублируются во многих местах. Как бы вы с этим справились?</summary><br><b>

Использование переменных может не быть хорошим решением, поскольку некоторые вещи не должны быть открыты и случайно переопределены. В таком случае вы можете использовать концепцию `locals`.

</b></details>

<details>
<summary>Каждый раз, когда происходят изменения в стандартах тегов (например, ваша команда решает изменить одно из названий тегов), вы обнаруживаете, что вам приходится изменять теги в нескольких файлах, и этот процесс кажется вам довольно утомительным. Что с этим можно сделать?</summary><br><b>

Вместо определения тегов на уровне ресурса рассмотрите возможность использования `default_tags` как части конфигурации провайдера.

</b></details>

<details>
<summary>Вы хотите изменить имя ресурса, но боитесь вызвать простой простой простой время простоя. Что можно сделать?</summary><br><b>

Если речь идет об изменении имени ресурса, вы можете использовать `terraform state mv <ORIGINAL_RESOURCE_NAME> <NEW_RESOURCE_NAME>`.
</b></details>

<details>
<summary>Вы пытаетесь развернуть кластер и приложение в этом кластере, но ресурс приложения был создан до кластера. Как управлять такой ситуацией?</summary><br><b>

Используйте мета-аргумент `depends_on` в определении ресурса приложения. Таким образом, приложение будет зависеть от ресурса кластера, и порядок создания ресурсов будет сохранён.
</b></details>

### [Назад к оглавлению](../index.md)
