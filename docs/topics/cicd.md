### [Назад к оглавлению](../index.md)

[Jenkins](https://www.jenkins.io/doc/developer/)<br>

## CI/CD

<details>
<summary>Что такое Непрерывная Интеграция (Continuous Integration)?</summary><br><b>

Практика разработки, при которой разработчики часто интегрируют код в общий репозиторий. Это может варьироваться от нескольких изменений каждый день или неделю до нескольких изменений за один час на больших проектах.

Каждое изменение кода (патч) проверяется, чтобы убедиться, что оно безопасно для слияния. В настоящее время это обычная практика тестировать изменение с помощью автоматизированной сборки, которая обеспечивает возможность интеграции кода. Это может быть одна сборка, которая запускает несколько тестов на разных уровнях (юнит-тесты, функциональные тесты и т.д.), или несколько отдельных сборок, которые должны пройти все или некоторые тесты для того, чтобы изменение было слито в репозиторий.
</b></details>

<details>
<summary>Что такое Непрерывное Развертывание (Continuous Deployment)?</summary><br><b>

Стратегия разработки, используемая разработчиками для автоматического развертывания программного обеспечения в продуктивной среде, при этом любое изменение кода должно проходить через фазу автоматизированного тестирования. Только когда это успешно, выпуск считается готовым для продуктивной среды. Это исключает любое человеческое взаимодействие и должно быть реализовано только после настройки производственных конвейеров с мониторингом и отчетностью в реальном времени о развернутых активах. Если будут обнаружены какие-либо проблемы в продуктивной среде, должно быть просто откатиться к предыдущему рабочему состоянию.

Для получения дополнительной информации, пожалуйста, прочитайте [здесь](https://www.atlassian.com/continuous-delivery/continuous-deployment).
</b></details>

<details>
<summary>Можете описать пример процесса CI (и/или CD), начиная с момента, когда разработчик отправил изменение/PR в репозиторий?</summary><br><b>

Существует множество ответов на этот вопрос, так как процессы CI различаются в зависимости от используемых технологий и типа проекта, в который было отправлено изменение. Такие процессы могут включать одну или несколько из следующих стадий:

* Компиляция 
* Сборка
* Установка
* Конфигурация
* Обновление
* Тестирование

Пример одного возможного ответа:

Разработчик отправил pull request к проекту. PR (pull request) инициировал две задачи (или одну комбинированную задачу). Одна задача для выполнения линтингового теста на изменение и вторая задача для сборки пакета, который включает отправленное изменение, и выполнения нескольких API/сценарных тестов с использованием этого пакета. Как только все тесты прошли и изменение было одобрено поддержкой/основной командой, оно сливается/отправляется в репозиторий. Если некоторые тесты не прошли, изменение не будет разрешено для слияния/отправки в репозиторий.

Совершенно другой ответ или процесс CI может описать, как разработчик отправляет код в репозиторий, после чего запускается рабочий процесс, чтобы собрать образ контейнера и отправить его в реестр. Как только в реестре, кластер k8s применяет новые изменения.
</b></details>

<details>
<summary>Что такое Непрерывная Доставка (Continuous Delivery)?</summary><br><b>

Стратегия разработки, используемая для частой доставки кода в QA и Ops для тестирования. Это подразумевает наличие промежуточной зоны, которая имеет функции, подобные производственным, где изменения могут быть приняты в продукцию только после ручного обзора. Из-за этого человеческого вовлечения, обычно есть временной лаг между выпуском и обзором, что делает его медленным и подверженным ошибкам по сравнению с непрерывным развертыванием.

Для получения дополнительной информации, пожалуйста, прочитайте [здесь](https://www.atlassian.com/continuous-delivery/continuous-deployment).
</b></details>

<details>
<summary>В чем разница между Непрерывной Доставкой и Непрерывным Развертыванием?</summary><br><b>

Обе концепции охватывают один и тот же процесс развертывания изменений, которые были собраны и/или протестированы в CI-пipelines.<br>
Разница между ними заключается в том, что Непрерывная Доставка не является полностью автоматизированным процессом, в отличие от Непрерывного Развертывания, где каждое изменение, протестированное в процессе, в конечном итоге разворачивается в продуктивной среде. В непрерывной доставке кто-то либо одобряет процесс развертывания, либо сам процесс развертывания основывается на ограничениях и условиях (например, временные ограничения развертывания каждую неделю/месяц...).
</b></details>

<details>
<summary>С какими практиками CI/CD вы знакомы? Или что вы считаете лучшими практиками CI/CD?</summary><br><b>

* Часто коммитить и тестировать.
* Тестовая/промежуточная среда должна быть клонированием производственной среды.
* Очищайте свои среды (например, ваши CI/CD пайплайны могут создать много ресурсов. Они также должны заботиться о очистке всего, что они создали).
* CI/CD пайплайны должны давать одинаковые результаты как при удаленном, так и при локальном выполнении.
* Рассматривайте CI/CD как еще одно приложение в вашей организации, а не как "клейкий" код.
* Запросные среды вместо заранее выделенных ресурсов для целей CI/CD.
* Этапы/задачи пайплайнов должны быть общими между приложениями или микросервисами (не переизобретайте общие задачи, такие как "клонирование проекта").
</b></details>

<details>
<summary>Вам дана пайплайн и пул с 3 рабочими: виртуальная машина, сервера и контейнер. Как вы решите, на каком из них запустить пайплайн?</summary><br><b>

Решение о том, какой тип рабочего (виртуальная машина, "bare-metal" или контейнер) использовать для запуска пайплайна, будет зависеть от нескольких факторов, включая природу пайплайна, требования к разрабатываемому программному обеспечению, доступные ресурсы и специфические цели и ограничения процесса разработки и развертывания. Вот некоторые соображения, которые могут помочь в принятии решения:

1. Требования пайплайна
2. Доступность ресурсов
3. Масштабируемость и гибкость
4. Требования к развертыванию и изоляции
5. Соображения безопасности
6. Рабочие процессы разработки и эксплуатации
7. Соображения по стоимости

Основываясь на этих соображениях, подходящий выбор рабочего (виртуальная машина, "bare-metal" или контейнер) для запуска пайплайна будет определяться с учетом плюсов и минусов каждого варианта и в соответствии со специфическими требованиями, ресурсами и целями процесса разработки и развертывания. Также может быть полезно проконсультироваться с соответствующими заинтересованными сторонами, такими как разработчики, операционные и инфраструктурные команды, для сбора мнений и принятия обоснованного решения.
</b></details>

<details>
<summary>Где вы храните CI/CD пайплайны? Почему?</summary><br><b>

Существует несколько подходов к тому, где хранить определения CI/CD пайплайнов:

1. Репозиторий приложения - хранить их в том же репозитории приложения, который они создают или тестируют (возможно, самый популярный вариант).
2. Центральный репозиторий - хранить все CI/CD пайплайны организации/проекта в одном отдельном репозитории (возможно, лучший подход, когда несколько команд тестируют один и тот же набор проектов и в итоге имеют много пайплайнов).
3. CI репозиторий для каждого репозитория приложения - отделить код, связанный с CI, от кода приложения, но не помещать всё в одном месте (возможно, худший вариант из-за обслуживания).
4. Платформа, где выполняются CI/CD пайплайны (например, Kubernetes кластер в случае Tekton/OpenShift Pipelines).
</b></details>

<details>
<summary>Как вы выполняете планирование емкости для своих CI/CD ресурсов? (например, серверы, хранилище и т.д.)</summary><br><b>

Планирование емкости для CI/CD ресурсов включает в себя оценку ресурсов, необходимых для поддержки CI/CD пайплайна, и обеспечение достаточной емкости инфраструктуры для удовлетворения требований пайплайна. Вот некоторые шаги для выполнения планирования емкости для ресурсов CI/CD:

1. Анализ рабочей нагрузки
2. Мониторинг текущего использования
3. Выявление узких мест ресурсов
4. Прогнозирование будущего спроса
5. Планирование роста
6. Рассмотрение вопросов масштабируемости и гибкости
7. Оценка затрат и бюджета
8. Непрерывный мониторинг и корректировка

Следуя этим шагам, вы можете эффективно планировать емкость для своих ресурсов CI/CD, обеспечивая наличие достаточных ресурсов для эффективной работы вашего пайплайна и удовлетворения требований вашего процесса разработки.
</b></details>

<details>
<summary>Как бы вы структурировали/реализовали CD для приложения, которое зависит от нескольких других приложений?</summary><br><b>

Реализация Непрерывного Развертывания (CD) для приложения, которое зависит от нескольких других приложений, требует тщательного планирования и координации, чтобы обеспечить плавное и эффективное развертывание изменений во всей экосистеме. Вот некоторые общие шаги для структурирования/реализации CD для приложения с зависимостями:

1. Определите пайплайн развертывания
2. Автоматизируйте процесс развертывания
3. Управление версиями и зависимостями
4. Непрерывная интеграция и тестирование
5. Пошаговые развертывания
6. Мониторинг и управление зависимостями
7. Тестирование по всей экосистеме
8. Стратегии отката и восстановления
9. Безопасность и соблюдение норм
10. Документация и коммуникация

Реализация CD для приложения с зависимостями требует тщательного планирования, координации и автоматизации для обеспечения эффективных и надежных развертываний. Следуя лучшим практикам, таким как автоматизация, управление версиями, тестирование, мониторинг, стратегии отката и эффективная коммуникация, вы можете обеспечить плавный и успешный процесс CD для вашей экосистемы приложений.
</b></details>

<details>
<summary>Как вы измеряете качество своего CI/CD? Существуют ли какие-либо метрики или KPI, которые вы используете для измерения качества?</summary><br><b>

Измерение качества процессов CI/CD имеет решающее значение для выявления областей для улучшения, обеспечения эффективной и надежной доставки программного обеспечения и достижения непрерывного улучшения. Вот некоторые общие метрики и KPI (ключевые показатели эффективности) для измерения качества CI/CD:

1. Процент успешных сборок: Эта метрика измеряет процент успешных сборок по сравнению с общим числом сборок. Высокий процент успешных сборок указывает на то, что большинство сборок успешны и пайплайн CI/CD стабилен.
2. Время сборки и развертывания: Эта метрика измеряет время, необходимое для сборки и развертывания изменений от момента отправки кода до продуктивной среды. Быстрое время сборки и развертывания указывает на более короткий цикл обратной связи и более быстрое время выхода на рынок.
3. Частота развертывания: Эта метрика измеряет частоту развертываний в продуктивной среде в течение определенного периода времени. Более высокая частота развертывания указывает на более быстрые циклы выпусков и более частые обновления в продуктивной среде.
4. Среднее время обнаружения (MTTD): Эта метрика измеряет среднее время, необходимое для обнаружения проблем или дефектов в пайплайне CI/CD или в продуктивной среде. Меньшее MTTD указывает на более быстрое обнаружение и разрешение проблем, что приводит к более высокому качеству и более надежным развертываниям.
5. Среднее время восстановления (MTTR): Эта метрика измеряет среднее время, необходимое для восстановления после проблем или инцидентов в пайплайне CI/CD или в продуктивной среде. Меньшее MTTR указывает на более быстрое восстановление и уменьшение времени простоя, что приводит к более высокой доступности и надежности.
6. Время цикла обратной связи: Эта метрика измеряет время, необходимое для получения обратной связи по изменениям в коде, включая обзоры кода, результаты тестов и другие механизмы обратной связи. Более быстрое время цикла обратной связи позволяет более быстрые итерации и более быстрое улучшение процесса CI/CD.
7. Удовлетворенность клиентов: Эта метрика измеряет удовлетворенность конечных пользователей или клиентов качеством и надежностью развернутого программного обеспечения. Более высокая удовлетворенность клиентов указывает на то, что процесс CI/CD доставляет высококачественное программное обеспечение, соответствующее ожиданиям клиентов.

Это всего лишь некоторые примеры метрик и KPI, которые можно использовать для измерения качества процессов CI/CD. Важно выбирать метрики, которые соответствуют целям и задачам вашей организации, и регулярно отслеживать и анализировать их, чтобы постоянно улучшать процесс CI/CD и обеспечивать высокое качество доставки программного обеспечения.
</b></details>

#### CI/CD - Jenkins

<details>
<summary>Что такое Jenkins? Для чего вы его использовали?</summary><br><b>

Jenkins - это инструмент автоматизации с открытым исходным кодом, написанный на Java, с плагинами, созданными для целей Непрерывной Интеграции. Jenkins используется для непрерывной сборки и тестирования ваших программных проектов, что упрощает разработчикам интеграцию изменений в проект и упрощает пользователям получение свежей сборки. Он также позволяет постоянно доставлять программное обеспечение, интегрируясь с большим количеством технологий тестирования и развертывания.

Jenkins интегрирует процессы жизненного цикла разработки всех типов, включая сборку, документы, тестирование, упаковку, стадию, развертывание, статический анализ и многое другое.
</b></details>

<details>
<summary>Каковы преимущества Jenkins перед его конкурентами? Можете сравнить его с одной из следующих систем?

  * Travis
  * Bamboo
  * Teamcity
  * CircleCI</summary><br><b>

Jenkins имеет несколько преимуществ перед своими конкурентами, включая Travis, Bamboo, TeamCity и CircleCI. Вот некоторые ключевые преимущества:

1. С открытым исходным кодом и бесплатно
2. Настраиваемый и гибкий
3. Широкий диапазон интеграций и плагинов
4. Активное и поддерживающее сообщество

При сравнении Jenkins с его конкурентами есть некоторые ключевые различия в функциональности и возможностях. Например:

- Travis: Travis - это облачная платформа CI/CD, которая известна своей простотой использования и быстрой настройкой. Однако у нее меньше вариантов настройки и интеграций по сравнению с Jenkins.
- Bamboo: Bamboo - это инструмент CI/CD от Atlassian, создателей JIRA и Confluence. Он предоставляет ряд функций для сборки, тестирования и развертывания программного обеспечения, но может быть более дорогим и сложным в настройке по сравнению с Jenkins.
- TeamCity: TeamCity - это инструмент CI/CD от JetBrains, создателей IntelliJ IDEA. Он предоставляет ряд функций для сборки, тестирования и развертывания программного обеспечения, но может быть более сложным и требовательным к ресурсам по сравнению с Jenkins.
- CircleCI: CircleCI - это облачная платформа CI/CD, которая известна своими быстрыми временем сборки и легкой интеграцией с GitHub. Однако она может быть более дорогой по сравнению с Jenkins, особенно для более крупных проектов.
</b></details>

<details>
<summary>Каковы ограничения или недостатки Jenkins?</summary><br><b>

Это может быть оценочный ответ:

* Устаревшие панели управления с не многими возможностями для настройки
* Готовность контейнеров (это улучшилось с Jenkins X)
* Сам по себе у него не так много функций. С другой стороны, существует множество плагинов, созданных сообществом, чтобы расширить его возможности.
* Управление Jenkins и его пайплайнами как код может быть настоящим кошмаром.
</b></details>

<details>
<summary>Объясните следующее:

- Задача
- Сборка
- Плагин
- Узел или Работник
- Исполнитель</summary><br><b>
- Задача - это определение автоматизации=что и где выполнять после нажатия пользователем "собрать".
- Сборка - это выполняющийся экземпляр задачи. В любой данный момент времени может быть одна или несколько сборок (если это не ограничено конфигурацией).
- Работник - это машина/экземпляр, на котором выполняется сборка. Когда сборка запускается, она "забирает" работника из пула для выполнения на нем.
- Исполнитель - это переменная работника, определяющая, сколько сборок может выполняться на этом работнике параллельно. Значение исполнителя 3 означает, что 3 сборки могут выполняться в любой момент на этом исполнителе (не обязательно одной и той же задачи. Любые сборки).
</b></details>

<details>
<summary>Какие плагины вы использовали в Jenkins?</summary><br><b>

Jenkins имеет обширную библиотеку плагинов, и наиболее часто используемые плагины зависят от конкретных потребностей и требований каждой организации. Однако вот некоторые из самых популярных и широко используемых плагинов в Jenkins:

- Pipeline: Этот плагин позволяет пользователям создавать и управлять сложными многостадийными пайплайнами с использованием простого и удобного скриптового языка. Он предоставляет мощный и гибкий способ автоматизации всего процесса доставки программного обеспечения, от коммита кода до развертывания.

- Git: Этот плагин обеспечивает интеграцию с Git, одной из самых популярных систем управления версиями на сегодняшний день. Он позволяет пользователям извлекать код из репозиториев Git, инициировать сборки на основе изменений кода и отправлять изменения кода обратно в Git.

- Docker: Этот плагин обеспечивает интеграцию с Docker, популярной платформой для сборки, отгрузки и запуска распределенных приложений. Он позволяет пользователям собирать и запускать Docker-контейнеры как часть процесса сборки, что упрощает и позволяет повторное развертывание приложений.

- JUnit: Этот плагин обеспечивает интеграцию с JUnit, популярным фреймворком модульного тестирования для Java-приложений. Он позволяет пользователям выполнять тесты JUnit как часть их процесса сборки и генерировать отчеты и статистику по результатам тестов.

- Cobertura: Этот плагин предоставляет отчетность по покрытию кода для Java-приложений. Он позволяет пользователям измерять покрытие кода их тестами и генерировать отчеты о том, какие части кода покрыты тестами.

- Email Extension: Этот плагин предоставляет расширенные возможности уведомлений по электронной почте для Jenkins. Он позволяет пользователям настраивать содержимое и формат уведомлений по электронной почте, включая вложения, и отправлять уведомления определенным пользователям или группам на основе результатов сборки.

- Artifactory: Этот плагин обеспечивает интеграцию с Artifactory, популярным хранилищем артефактов для хранения и управления бинарными файлами и зависимостями. Он позволяет пользователям публиковать и получать артефакты из Artifactory как часть их процесса сборки.

- SonarQube: Этот плагин обеспечивает интеграцию с SonarQube, популярным инструментом анализа качества кода. Он позволяет пользователям выполнять проверки качества кода и генерировать отчеты по метрикам качества кода, таким как сложность кода, дубликаты кода и покрытие кода.
</b></details>

<details>
<summary>Вы использовали Jenkins для процессов CI или CD? Можете описать их?</summary><br><b>

Допустим, у нас есть веб-приложение, построенное с использованием Node.js, и мы хотим автоматизировать его процесс сборки и развертывания с помощью Jenkins. Вот как мы можем настроить простой CI/CD пайплайн с использованием Jenkins:

1. Установите Jenkins: Мы можем установить Jenkins на выделенном сервере или на облачной платформе, такой как AWS или Google Cloud.
2. Установить необходимые плагины: В зависимости от конкретных требований проекта, возможно, нам придется установить такие плагины, как NodeJS, Git, Docker и любые другие плагины, требуемые проектом.
3. Создать новую задачу: В Jenkins задача - это определенный набор инструкций для автоматизации конкретной задачи. Мы можем создать новую задачу и настроить ее на сборку нашего приложения на Node.js.
4. Настроить задачу: Мы можем настроить задачу для извлечения последнего кода из репозитория Git, установки необходимых зависимостей с помощью Node.js, выполнения модульных тестов и сборки приложения с использованием скрипта сборки.
5. Настроить окружение развертывания: Мы можем установить отдельное окружение для развертывания приложения, например, промежуточное или продуктивное окружение. Мы можем использовать Docker для создания образа контейнера приложения и развернуть его в окружении.
6. Настроить непрерывное развертывание: Мы можем настроить задачу на автоматическое развертывание приложения в развертываемое окружение, если сборка и тесты прошли успешно.
7. Мониторинг и устранение неполадок: Мы можем следить за пайплайном на наличие ошибок или сбоев и устранять любые возникающие проблемы.

Это всего лишь простой пример CI/CD пайплайна с использованием Jenkins, и конкретные детали реализации могут варьироваться в зависимости от требований проекта.
</b></details>

<details>
<summary>Какие типы задач существуют? Какие типы вы использовали?</summary><br><b>

В Jenkins есть различные типы задач, включая:

1. Freestyle job: Это самый распространенный тип задачи в Jenkins, который позволяет пользователям определять пользовательские шаги сборки и настраивать различные параметры, включая триггеры сборки, опрос SCM и действия после сборки.
2. Pipeline job: Pipline job - это новая функция в Jenkins, которая позволяет пользователям определять пайплайн задач, который может выполняться в определенном порядке. Пайплайн может быть определен с помощью Jenkinsfile, который предоставляет синтаксис, похожий на скрипт, для определения этапов, шагов и условий пайплайна.
3. Multi-configuration job: Этот тип задачи позволяет пользователям выполнять одну и ту же задачу с несколькими конфигурациями, такими как различные операционные системы, браузеры или устройства. Jenkins выполнит задачу для каждой указанной конфигурации, предоставляя матрицу результатов.
4. Maven job: Этот тип задачи специально предназначен для сборки Java-приложений с использованием инструмента сборки Maven. Jenkins выполнит процесс сборки Maven, включая компиляцию, тестирование и упаковку приложения.
5. Parameterized job: Этот тип задачи позволяет пользователям определять параметры, которые могут быть переданы в процесс сборки во время выполнения. Параметры могут использоваться для настройки процесса сборки, например, указания номера версии или целевого окружения.
</b></details>

<details>
<summary>Как вы уведомляли пользователей о результатах сборки? Какие способы существуют для отчетности о результатах?</summary><br><b>

Вы можете сообщать через:
  * Электронная почта
  * Мессенджеры
  * Дашборды

У каждого из этих методов есть свои недостатки и преимущества. Например, электронная почта может быть игнорирована, если отправляется слишком часто.
</b></details>

<details>
<summary>Каждый раз, когда в проект вносится изменение, вы хотите запускать модульные тесты. Опишите подробно, каким образом будет выглядеть ваш пайплайн и что будет выполняться на каждом этапе.</summary><br><b>

У пайплайнов будет несколько этапов:

  * Клонировать проект
  * Установить зависимости тестирования (например, если мне нужно установить пакет tox для запуска тестов, я установлю его на этом этапе)
  * Выполнить модульные тесты
  * (Опционально) отчет о результатах (например, по электронной почте пользователям)
  * Архивировать соответствующие логи/файлы
</b></details>

<details>
<summary>Как обезопасить Jenkins?</summary><br><b>

 [Документация Jenkins](https://www.jenkins.io/doc/book/security/securing-jenkins/) предоставляет некоторые базовые вводные сведения о том, как защитить ваш сервер Jenkins.
</b></details>

<details>
<summary>Опишите, как вы добавляете новые узлы (агенты) в Jenkins</summary><br><b>

Вы можете описать способ добавления новых узлов через UI, но лучше объяснить, как это сделать масштабируемым способом, например, с помощью скрипта или использования динамичного источника для узлов, как в одном из существующих облаков.
</b></details>

<details>
<summary>Как запрашивать несколько узлов для одной конкретной сборки?</summary><br><b>

Для задания нескольких узлов для одной конкретной сборки в Jenkins можно использовать функцию "Параллельно" в скрипте пайплайна. Функция "Параллельно" позволяет выполнить несколько этапов параллельно, и каждый этап может выполняться на своем узле.

Вот пример скрипта пайплайна, который демонстрирует, как запрашивать несколько узлов для одной конкретной сборки:

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            parallel {
                stage('Node 1') {
                    agent { label 'node1' }
                    steps {
                        // Запуск команд сборки на Узле 1
                    }
                }
                stage('Node 2') {
                    agent { label 'node2' }
                    steps {
                        // Запуск команд сборки на Узле 2
                    }
                }
                stage('Node 3') {
                    agent { label 'node3' }
                    steps {
                        // Запуск команд сборки на Узле 3
                    }
                }
            }
        }
        stage('Deploy') {
            agent any
            steps {
                // Развертывание собранных артефактов
            }
        }
    }
}
```

В этом примере этап "Сборка" состоит из трех параллельных этапов, каждый из которых выполняется на различном узле, обозначенном как "node1", "node2" и "node3". Этап "Развертывание" запускается после завершения сборки и выполняется на любом доступном узле.

Чтобы использовать этот скрипт пайплайна, необходимо, чтобы три узла (node1, node2 и node3) были настроены в Jenkins. Также стоит убедиться, что необходимые команды сборки и зависимости установлены на каждом узле.
</b></details>

<details>
<summary>Каждый раз, когда сборка завершается неудачно, вы хотите уведомить команду, ответственную за задачу, о сбое и предоставить причину сбоя. Как бы вы это сделали?</summary><br><b>

В Jenkins вы можете использовать плагин "Email Notification" для уведомления команды, когда сборка завершается с ошибкой. Вот шаги для настройки уведомлений по электронной почте для неудачных сборок:

1. Установите плагин "Email Notification", если он еще не установлен в Jenkins.
2. Перейдите на страницу конфигурации задачи Jenkins и щелкните "Настроить".
3. Прокрутите вниз до раздела "После сборки" и нажмите "Добавить действие после сборки".
4. Выберите "Редактируемое уведомление по электронной почте" из списка вариантов.
5. Заполните необходимые поля, такие как адреса электронной почты получателей, тема и содержание письма. Вы можете использовать переменные окружения Jenkins, такие как ${BUILD_URL} и ${BUILD_LOG}, чтобы включить информацию, специфичную для сборки, в содержание письма.
6. В разделе "Расширенные настройки" выберите "Отправить получателям" и выберите "Только в случае сбоя" из выпадающего меню.
7. Нажмите "Сохранить", чтобы сохранить конфигурацию задачи.

С такой настройкой Jenkins будет отправлять уведомление по электронной почте указанным получателям каждый раз, когда сборка завершится с ошибкой, предоставляя им причину сбоя и любую другую соответствующую информацию.
</b></details>

<details>
<summary>В вашей организации есть четыре команды. Как приоритизировать сборки каждой команды? Так, чтобы задачи команды X всегда выполнялись раньше задач команды Y, например?</summary><br><b>

В Jenkins вы можете приоритизировать сборки каждой команды, используя плагин "Priority Sorter". Вот шаги для настройки приоритета сборок:

1. Установите плагин "Priority Sorter", если он еще не установлен в Jenkins.
2. Перейдите на страницу конфигурации системы Jenkins и щелкните "Настроить глобальную безопасность". Прокрутите вниз до раздела "Контроль доступа" и нажмите "На уровне проекта".
3. В разделе "Действия по умолчанию для проекта" выберите "Настроить триггеры сборки и выполнение" из выпадающего меню. Нажмите "Добавить пользователя или группу" и добавьте группы, представляющие каждую команду в вашей организации.
4. Перейдите на страницу конфигурации каждой задачи Jenkins и щелкните "Настроить". Прокрутите вниз до раздела "Среда сборки" и нажмите "Добавить шаг сборки". Выберите "Установить приоритет сборки с помощью Priority Sorter" из списка вариантов.
5. Установите приоритет задачи в зависимости от команды, которой она принадлежит. Например, если команда X отвечает за задачу, установите приоритет на более высокий, чем за задачи команды Y. Нажмите "Сохранить", чтобы сохранить конфигурацию задачи.

С такой настройкой Jenkins будет приоритизировать сборки каждой команды на основе установленного значения приоритета в конфигурации задачи. Задачи, принадлежащие команде X, будут иметь более высокий приоритет, чем задачи, принадлежащие команде Y, обеспечивая их выполнение в первую очередь.
</b></details>

<details>
<summary>Если вы управляете десятком задач, вы, вероятно, можете использовать UI Jenkins. Но как вы управляете созданием и удалением сотен задач каждую неделю/месяц?</summary><br><b>

Управление созданием и удалением сотен задач каждую неделю/месяц в Jenkins может быть громоздкой задачей, если делать это вручную через интерфейс пользователя. Вот некоторые подходы для эффективного управления большим количеством задач:

1. Используйте шаблоны задач
2. Используйте Job DSL
3. Используйте REST API Jenkins
4. Используйте инструмент управления конфигурацией
5. Используйте инструмент управления задачами Jenkins
</b></details>

<details>
<summary>Каковы некоторые ограничения Jenkins?</summary><br><b>

  * Тестирование взаимозависимостей (изменения из нескольких проектов вместе)
  * Запуск сборок из любой стадии (хотя Cloudbees реализовали нечто под названием контрольные точки).
</b></details>

<details>
<summary>В чем разница между скриптовым пайплайном и декларативным пайплайном? Какой тип вы используете?</summary><br><b>

Jenkins поддерживает два типа пайплайнов: скриптовые и декларативные пайплайны.

Скриптовые пайплайны используют синтаксис Groovy и обеспечивают высокую степень гибкости и контроля над процессом сборки. Скриптовые пайплайны позволяют разработчикам писать пользовательский код для обработки сложных сценариев, но могут быть сложными и трудными в обслуживании.

Декларативные пайплайны являются более новой функцией и обеспечивают более простой способ определения пайплайнов с использованием синтаксиса YAML. Декларативные пайплайны предоставляют более структурированный и целенаправленный способ определения сборок, облегчая начало работы с пайплайнами и уменьшая риск ошибок.

Некоторые ключевые различия между двумя типами пайплайнов:

1. Синтаксис: Скриптовые пайплайны используют синтаксис Groovy, в то время как декларативные пайплайны используют синтаксис YAML.
2. Структура: Декларативные пайплайны имеют более структурированный формат и определяют конкретные этапы, в то время как скриптовые пайплайны обеспечивают большую гибкость в определении этапов и шагов сборки.
3. Обработка ошибок: Декларативные пайплайны предоставляют более комплексную систему обработки ошибок с встроенными условиями и действиями, в то время как скриптовые пайплайны требуют более ручной обработки ошибок.
4. Удобство использования: Декларативные пайплайны проще в использовании для новичков и имеют более простой синтаксис, в то время как скриптовые пайплайны требуют больше опыта в Groovy и могут быть более сложными.
5. Обслуживание: Декларативные пайплайны легче обслуживать и модифицировать с меньшими затратами времени по сравнению со скриптовыми пайплайнами, которые могут быть более трудными для изменения и расширения с течением времени.

Мне знакомы оба типа пайплайнов, но в основном я предпочитаю декларативные пайплайны за их удобство использования и простоту.
</b></details>

<details>
<summary>Как бы вы реализовали возможность запуска сборки с определенного этапа, а не с начала?</summary><br><b>

Чтобы реализовать возможность запуска сборки с определенного этапа, а не с начала в пайплайне Jenkins, мы можем использовать директиву `when` вместе с настраиваемым параметром, чтобы определить стартовую стадию. Вот шаги для реализации этого:

1. Добавьте настраиваемый параметр в пайплайн. Этот параметр может быть простой строкой или более сложным типом данных, например, картой.
    
    ```groovy
    parameters {
        string(name: 'START_STAGE', defaultValue: '', description: 'Имя этапа, с которого начать сборку')
    }
    ```
    
2. Используйте директиву `when`, чтобы условно выполнить этапы на основе значения параметра `START_STAGE`.
    
    ```groovy
    stage('Build') {
        when {
            expression {
                params.START_STAGE == '' || currentStage.name == params.START_STAGE
            }
        }
        // Шаги сборки здесь
    }
    
    stage('Test') {
        when {
            expression {
                params.START_STAGE == '' || currentStage.name == params.START_STAGE || previousStage.result == 'SUCCESS'
            }
        }
        // Шаги тестирования здесь
    }
    
    stage('Deploy') {
        when {
            expression {
                params.START_STAGE == '' || currentStage.name == params.START_STAGE || previousStage.result == 'SUCCESS'
            }
        }
        // Шаги развертывания здесь
    }
    ```
    

  В этом примере мы используем директиву `when`, чтобы выполнить каждый этап только в том случае, если параметр `START_STAGE` пуст или совпадает с именем текущего этапа. Кроме того, для этапов "Тестирование" и "Развертывание" мы также проверяем, завершилась ли предыдущая стадия успешно перед запуском.

3. Запустите пайплайн и передайте параметр `START_STAGE`, когда это необходимо.
    
    ```groovy
    pipeline {
        agent any
        parameters {
            string(name: 'START_STAGE', defaultValue: '', description: 'Имя этапа, с которого начать сборку')
        }
        stages {
            stage('Build') {
                // Шаги сборки здесь
            }
            stage('Test') {
                // Шаги тестирования здесь
            }
            stage('Deploy') {
                // Шаги развертывания здесь
            }
        }
    }
    ```
    

При запуске пайплайна вы можете передать параметр `START_STAGE`, чтобы начать сборку с определенного этапа.

Например, если вы хотите начать сборку с этапа "Тестирование", вы можете запустить пайплайн с параметром `START_STAGE`, установленным на `'Test'`:

```groovy
pipeline?START_STAGE=Test
```

Это заставит пайплайн пропустить этап "Сборка" и начать сразу с этапа "Тестирование".
</b></details>

<details>
<summary>Есть ли у вас опыт разработки плагинов для Jenkins? Можете описать этот опыт?</summary><br><b>

Разработка плагина для Jenkins требует знаний Java и знакомства с API Jenkins. Процесс обычно включает настройку среды разработки, создание нового проекта плагина, определение точек расширения плагина и реализацию необходимого функционала с использованием кода Java. После того как плагин будет разработан, его можно упаковать и развернуть в Jenkins.

Экосистема плагинов Jenkins обширна, и существует множество ресурсов, которые могут помочь в разработке плагинов, включая документацию, форумы и онлайн-сообщества. Кроме того, Jenkins предоставляет инструменты, такие как Jenkins Plugin POM Generator и Jenkins Plugin Manager, чтобы помочь в разработке и управлении плагинами.
</b></details>

<details>
<summary>Вы писали скрипты Jenkins? Если да, для чего и как они работают?</summary><br><b>
</b></details>

#### CI/CD - GitHub Actions

<details>
<summary>Что такое Workflow в GitHub Actions?</summary><br><b>

Файл YAML, который определяет действия автоматизации и инструкции для выполнения при определенном событии.<br>
Файл размещается непосредственно в репозитории.

Workflow может быть чем угодно - запуск тестов, компиляция кода, создание пакетов и т.д.
</b></details>

<details>
<summary>Что такое Runner в GitHub Actions?</summary><br><b>

Workflow должен быть выполнен где-то. Среда, в которой выполняется workflow, называется Runner.<br>
Runner может быть локальным хостом или хостингом GitHub.
</b></details>

<details>
<summary>Что такое Job в GitHub Actions?</summary><br><b>

Задача - это серия шагов, которые выполняются в одном и том же Runner/окружении.<br>
Workflow должен включать как минимум одну задачу.
</b></details>

<details>
<summary>Что такое Action в GitHub Actions?</summary><br><b>

Action - это наименьшая единица в workflow. Она включает команды, которые выполняются в рамках задачи.
</b></details>

<details>
<summary>Для чего используется атрибут/директива 'on' в workflow GitHub Actions?</summary><br><b>

Указать, при каких событиях будет инициирован workflow.<br>
Например, вы можете настроить workflow, чтобы он запускался каждый раз, когда в репозитории происходит изменение.
</b></details>

<details>
<summary>Верно или неверно? В GitHub Actions задачи выполняются параллельно по умолчанию.</summary><br><b>

Верно.
</b></details>

<details>
<summary>Как создать зависимости между задачами так, чтобы одна задача выполнялась после другой?</summary><br><b>

С помощью атрибута/директивы "needs".

```
jobs:
  job1:
  job2:
    needs: job1
```

В приведенном выше примере job1 должен успешного завершиться, прежде чем job2 будет запущена.
</b></details>

<details>
<summary>Как добавить Workflow в репозиторий?</summary><br><b>
CLI:

1. Создайте директорию `.github/workflows` в репозитории.
2. Добавьте YAML файл.

UI:

1. На странице репозитория нажмите на "Actions".
2. Выберите workflow и нажмите "Настроить этот workflow".
</b></details>

#### Zuul

<details>
<summary>В Zuul, что такое <code>check</code> пайплайны?</summary><br><b>

Пайплайны `check` запускаются, когда патч загружается в систему ревью кода (например, Gerrit).<br>
</b></details>

<details>
<summary>В Zuul, что такое <code>gate</code> пайплайны?</summary><br><b>

Пайплайны `gate` запускаются, когда рецензент кода одобряет изменение в системе ревью кода (например, Gerrit).
</b></details>

<details>
<summary>Верно или неверно? Пайплайны <code>gate</code> запускаются после пайплайнов <code>check</code>.</summary><br><b>

Верно. Пайплайны `check` запускаются, когда изменение загружается, тогда как пайплайны `gate` запускаются, когда изменение одобрено рецензентом.
</b></details>

### [Назад к оглавлению](../index.md)
